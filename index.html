<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktivn√≠ uƒçen√≠ informatiky</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .navbar {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
        }
        
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            gap: 1rem;
        }
        
        .nav-item {
            position: relative;
        }
        
        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 25px;
            color: white;
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .nav-link.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .hamburger {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 0.5rem;
        }
        
        .hamburger span {
            width: 25px;
            height: 3px;
            background: white;
            margin: 3px 0;
            transition: 0.3s;
        }
        
        .main-content {
            margin-top: 80px;
            padding: 20px;
            min-height: calc(100vh - 80px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .topic-section {
            display: none;
        }
        
        .topic-section.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 2.5em;
        }
        
        .input-section {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        label {
            font-weight: bold;
            color: #fff;
        }
        
        input[type="text"], input[type="number"] {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
        }
        
        input[type="text"] {
            width: 300px;
        }
        
        input[type="number"] {
            width: 120px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .preset-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .main-content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .main-content-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .section h2 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        /* Responsive Navigation */
        @media (max-width: 768px) {
            .hamburger {
                display: flex;
            }
            
            .nav-menu {
                position: fixed;
                left: -100%;
                top: 70px;
                flex-direction: column;
                background: rgba(0, 0, 0, 0.95);
                width: 100%;
                text-align: center;
                transition: 0.3s;
                backdrop-filter: blur(10px);
                padding: 2rem 0;
            }
            
            .nav-menu.active {
                left: 0;
            }
            
            .nav-link {
                margin: 0.5rem 1rem;
            }
        }
        
        /* Spoleƒçn√© styly pro obƒõ sekce */
        .iteration-table, .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .iteration-table th, .iteration-table td,
        .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }
        
        .iteration-table th, .table th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .iteration-table tr:nth-child(even),
        .table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .combined-term {
            background: #e8f5e8 !important;
            font-weight: bold;
        }
        
        .binary-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
            letter-spacing: 2px;
        }
        
        .sign { color: #e74c3c; }
        .exponent { color: #f39c12; }
        .mantissa { color: #27ae60; }
        
        .final-result {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .step-explanation, .calculation-step {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .info-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .kmap-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .kmap {
            border-collapse: collapse;
            border: 2px solid #333;
            background: white;
        }
        
        .kmap td, .kmap th {
            width: 40px;
            height: 40px;
            border: 1px solid #666;
            text-align: center;
            vertical-align: middle;
            font-weight: bold;
        }
        
        .kmap th {
            background: #3498db;
            color: white;
        }
        
        .kmap .one {
            background: #e74c3c;
            color: white;
        }
        
        .kmap .zero {
            background: #ecf0f1;
            color: #7f8c8d;
        }
        
        .coverage-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }
        
        .coverage-table th,
        .coverage-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .coverage-table th {
            background: #2c3e50;
            color: white;
        }
        
        .coverage-table .covered {
            background: #2ecc71;
            color: white;
            font-weight: bold;
        }
        
        .welcome-section {
            text-align: center;
            padding: 3rem 0;
        }
        
        .welcome-section h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .welcome-section p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }
        
        .topic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }
        
        .topic-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        
        .topic-card:hover {
            transform: translateY(-5px);
        }
        
        .topic-card h3 {
            margin-bottom: 1rem;
            color: #fff;
        }
        
        .topic-card p {
            opacity: 0.8;
        }

        .formula-display {
            background: #f8f9fa;
            border: 2px solid #3498db;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            margin: 15px 0;
            color: #2c3e50;
        }
        
        .step-highlight {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
            border-radius: 0 5px 5px 0;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">üìö CS Learning Platform</div>
            <ul class="nav-menu" id="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link active" onclick="showSection('welcome')">
                        üè† √övod
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('quine-mccluskey')">
                        üîß Quine-McCluskey
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('ieee754')">
                        üî¢ IEEE 754
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('binary-arithmetic')">
                        üßÆ Bin√°rn√≠ aritmetika
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('ieee754-converter')">
                        üîÑ IEEE 754 P≈ôevodn√≠k
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('ieee754-multiply')">
                        ‚úñÔ∏è IEEE 754 N√°soben√≠
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('coming-soon')">
                        ‚≠ê Dal≈°√≠ t√©mata
                    </a>
                </li>
            </ul>
            <div class="hamburger" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main class="main-content">
        <div class="container">
            <!-- √övodn√≠ sekce -->
            <section id="welcome" class="topic-section active">
                <div class="welcome-section">
                    <h1>üéì Interaktivn√≠ uƒçen√≠ informatiky</h1>
                    <p>Prozkoumej slo≈æit√© koncepty informatiky pomoc√≠ interaktivn√≠ch n√°stroj≈Ø a vizualizac√≠</p>
                    
                    <div class="topic-grid">
                        <div class="topic-card" onclick="showSection('quine-mccluskey')">
                            <h3>üîß Quine-McCluskey metoda</h3>
                            <p>Minimalizace logick√Ωch funkc√≠ krok za krokem. Nauƒçte se, jak algoritmus systematicky redukuje Boolean v√Ωrazy na nejjednodu≈°≈°√≠ formu.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('ieee754')">
                            <h3>üî¢ IEEE 754 Sƒç√≠t√°n√≠</h3>
                            <p>Pochopte, jak poƒç√≠taƒçe sƒç√≠taj√≠ desetinn√° ƒç√≠sla. Sledujte proces sƒç√≠t√°n√≠ floating point ƒç√≠sel bit po bitu.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('ieee754-converter')">
                            <h3>üîÑ IEEE 754 P≈ôevodn√≠k</h3>
                            <p>P≈ôev√°dƒõjte mezi desetinn√Ωmi ƒç√≠sly a IEEE 754 reprezentac√≠ s detailn√≠m postupem a vysvƒõtlen√≠m ka≈æd√©ho kroku.</p>
                        </div>
                        <div class="topic-card" onclick="showSection('ieee754-multiply')">
                            <h3>‚úñÔ∏è IEEE 754 N√°soben√≠</h3>
                            <p>Nauƒçte se, jak poƒç√≠taƒçe n√°sob√≠ desetinn√° ƒç√≠sla ve floating point aritmetice s detailn√≠m postupem ka≈æd√©ho kroku.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('binary-arithmetic')">
                            <h3>üßÆ Bin√°rn√≠ aritmetika</h3>
                            <p>Nauƒçte se sƒç√≠tat, odƒç√≠tat, n√°sobit a dƒõlit v bin√°rn√≠ soustavƒõ. Pochopte, jak CPU prov√°d√≠ z√°kladn√≠ aritmetick√© operace.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('coming-soon')">
                            <h3>‚≠ê P≈ôipravujeme...</h3>
                            <p>Dal≈°√≠ t√©mata jako algoritmy ≈ôazen√≠, datov√© struktury, nebo s√≠≈•ov√© protokoly budou brzy dostupn√©!</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Quine-McCluskey sekce -->
            <section id="quine-mccluskey" class="topic-section">
                <h1>üîß Quine-McCluskey metoda a Petrickova funkce</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="minterms">Mintermy (ƒç√°rkou oddƒõlen√©):</label>
                        <input type="text" id="minterms" value="2,4,6,8,9,10,12,13,15" placeholder="nap≈ô. 2,4,6,8,9,10,12,13,15">
                        <button onclick="runQuineMcCluskey()">üöÄ Spustit minimalizaci</button>
                    </div>
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadQMPreset('2,4,6,8,9,10,12,13,15')">P≈ô√≠klad z obr√°zku</button>
                        <button class="preset-btn" onclick="loadQMPreset('0,1,2,5,8,9,10')">P≈ô√≠klad 2</button>
                        <button class="preset-btn" onclick="loadQMPreset('4,5,6,8,9,10,13')">P≈ô√≠klad 3</button>
                        <button class="preset-btn" onclick="loadQMPreset('1,3,7,11,15')">P≈ô√≠klad 4</button>
                    </div>
                </div>
                
                <div class="main-content-grid">
                    <div class="section">
                        <h2>üìä Quine-McCluskey iterace</h2>
                        <div id="qm-iterations"></div>
                    </div>
                    
                    <div class="section">
                        <h2>üó∫Ô∏è Karnaughova mapa</h2>
                        <div id="qm-kmap"></div>
                    </div>
                </div>
                
                <div class="section full-width">
                    <h2>üßÆ Petrickova funkce a pokryt√≠</h2>
                    <div id="qm-petrick"></div>
                    <div id="qm-coverage"></div>
                    <div id="qm-final-result"></div>
                </div>
            </section>

            <!-- Bin√°rn√≠ aritmetika sekce -->
            <section id="binary-arithmetic" class="topic-section">
                <h1>üßÆ Bin√°rn√≠ aritmetika</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="bin-num1">ƒå√≠slo A (bin√°rnƒõ nebo desetinnƒõ):</label>
                        <input type="text" id="bin-num1" value="01011010" placeholder="nap≈ô. 01011010 nebo 90">
                        
                        <label for="bin-operation">Operace:</label>
                        <select id="bin-operation" style="padding: 10px 15px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.9); color: #333; font-size: 16px;">
                            <option value="add">Sƒç√≠t√°n√≠ (+)</option>
                            <option value="subtract">Odƒç√≠t√°n√≠ (-)</option>
                            <option value="multiply">N√°soben√≠ (√ó)</option>
                            <option value="divide">Dƒõlen√≠ (√∑)</option>
                            <option value="non-restoring">Dƒõlen√≠ bez restaurace</option>
                        </select>
                        
                        <label for="bin-num2">ƒå√≠slo B (bin√°rnƒõ nebo desetinnƒõ):</label>
                        <input type="text" id="bin-num2" value="00101100" placeholder="nap≈ô. 00101100 nebo 44">
                        
                        <button onclick="calculateBinaryArithmetic()">üöÄ Spoƒç√≠tat</button>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadBinaryPreset('01011010', '00101100', 'subtract')">Odƒç√≠t√°n√≠: 90 - 44</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('00110111', '00000101', 'divide')">Dƒõlen√≠: 55 √∑ 5</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('00000100', '00000111', 'multiply')">N√°soben√≠: 4 √ó 7</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('01000100', '01011010', 'add')">Sƒç√≠t√°n√≠: 68 + 90</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('00011110', '00000011', 'non-restoring')">Bez restaurace: 30 √∑ 3</button>
                    </div>
                </div>
                
                <div id="binary-results"></div>
            </section>

            <!-- IEEE 754 sekce -->
            <section id="ieee754" class="topic-section">
                <h1>üî¢ IEEE 754 Sƒç√≠t√°n√≠ ƒç√≠sel (32-bit Float)</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="ieee-num1">ƒå√≠slo A:</label>
                        <input type="number" id="ieee-num1" value="3.75" step="any">
                        
                        <label for="ieee-num2">ƒå√≠slo B:</label>
                        <input type="number" id="ieee-num2" value="1.25" step="any">
                        
                        <button onclick="calculateIEEE754Addition()">üßÆ Spoƒç√≠tat sƒç√≠t√°n√≠</button>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadIEEEExample(3.75, 1.25)">P≈ô√≠klad 1: 3.75 + 1.25</button>
                        <button class="preset-btn" onclick="loadIEEEExample(5.5, -2.25)">P≈ô√≠klad 2: 5.5 + (-2.25)</button>
                        <button class="preset-btn" onclick="loadIEEEExample(0.125, 0.375)">P≈ô√≠klad 3: 0.125 + 0.375</button>
                        <button class="preset-btn" onclick="loadIEEEExample(7.0, 0.5)">P≈ô√≠klad 4: 7.0 + 0.5</button>
                    </div>
                </div>
                
                <div id="ieee-results"></div>
            </section>

            <section id="ieee754-converter" class="topic-section">
                <h1>üîÑ IEEE 754 P≈ôevodn√≠k</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="converter-input">Vstup:</label>
                        <input type="text" id="converter-input" value="3.75" placeholder="nap≈ô. 3.75 nebo 01000000011100000000000000000000">
                        
                        <label for="converter-type">Typ:</label>
                        <select id="converter-type" style="padding: 10px 15px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.9); color: #333; font-size: 16px;">
                            <option value="decimal">Desetinn√© ‚Üí IEEE 754</option>
                            <option value="binary">IEEE 754 ‚Üí Desetinn√©</option>
                        </select>
                        
                        <button onclick="convertIEEE754()">üîÑ P≈ôev√©st</button>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadConverterExample('3.75', 'decimal')">3.75 ‚Üí IEEE</button>
                        <button class="preset-btn" onclick="loadConverterExample('-2.5', 'decimal')">-2.5 ‚Üí IEEE</button>
                        <button class="preset-btn" onclick="loadConverterExample('01000000011100000000000000000000', 'binary')">IEEE ‚Üí Decimal</button>
                        <button class="preset-btn" onclick="loadConverterExample('0.125', 'decimal')">0.125 ‚Üí IEEE</button>
                        <button class="preset-btn" onclick="loadConverterExample('11000001001000000000000000000000', 'binary')">-10.0 ‚Üí Decimal</button>
                        <button class="preset-btn" onclick="loadConverterExample('0', 'decimal')">Nula ‚Üí IEEE</button>
                    </div>
                </div>
                
                <div id="converter-results"></div>
            </section>

            <section id="ieee754-multiply" class="topic-section">
            <h1>‚úñÔ∏è IEEE 754 N√°soben√≠ ƒç√≠sel (32-bit Float)</h1>
            
            <div class="input-section">
                <div class="controls">
                    <label for="ieee-mult-num1">ƒå√≠slo X:</label>
                    <input type="number" id="ieee-mult-num1" value="-0.3" step="any">
                    
                    <label for="ieee-mult-num2">ƒå√≠slo Y:</label>
                    <input type="number" id="ieee-mult-num2" value="500.25" step="any">
                    
                    <button onclick="calculateIEEE754Multiplication()">üßÆ Spoƒç√≠tat n√°soben√≠</button>
                </div>
                
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="loadIEEEMultExample(-0.3, 500.25)">P≈ô√≠klad z obr√°zku: -0.3 √ó 500.25</button>
                    <button class="preset-btn" onclick="loadIEEEMultExample(3.5, 2.25)">P≈ô√≠klad 2: 3.5 √ó 2.25</button>
                    <button class="preset-btn" onclick="loadIEEEMultExample(1.5, -4.0)">P≈ô√≠klad 3: 1.5 √ó (-4.0)</button>
                    <button class="preset-btn" onclick="loadIEEEMultExample(0.25, 0.125)">P≈ô√≠klad 4: 0.25 √ó 0.125</button>
                </div>
            </div>
            
            <div id="ieee-mult-results"></div>
        </section>

            <!-- Coming Soon sekce -->
            <section id="coming-soon" class="topic-section">
                <div class="welcome-section">
                    <h1>‚≠ê Dal≈°√≠ t√©mata v p≈ô√≠pravƒõ</h1>
                    <p>P≈ôipravujeme dal≈°√≠ interaktivn√≠ n√°stroje pro uƒçen√≠ informatiky</p>
                    
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h3>üóÇÔ∏è Datov√© struktury</h3>
                            <p>Vizualizace strom≈Ø, hashmap, linked list≈Ø a dal≈°√≠ch datov√Ωch struktur s interaktivn√≠mi operacemi.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>üîÄ Algoritmy ≈ôazen√≠</h3>
                            <p>Sledujte algoritmy jako Quick Sort, Merge Sort, Bubble Sort krok za krokem s animacemi.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>üåê S√≠≈•ov√© protokoly</h3>
                            <p>Pochopte TCP/IP, HTTP, DNS a dal≈°√≠ protokoly pomoc√≠ interaktivn√≠ch diagram≈Ø.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>üîê Kryptografie</h3>
                            <p>Prozkoumejte ≈°ifrovac√≠ algoritmy, hash funkce a digit√°ln√≠ podpisy.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>ü§ñ Automatov√© teorie</h3>
                            <p>Koneƒçn√© automaty, regul√°rn√≠ v√Ωrazy a form√°ln√≠ jazyky s interaktivn√≠mi simul√°tory.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>üíæ Operaƒçn√≠ syst√©my</h3>
                            <p>Pl√°nov√°n√≠ proces≈Ø, spr√°va pamƒõti a filesyst√©my s praktick√Ωmi uk√°zkami.</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        // Navigation functionality
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.topic-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Add active class to corresponding nav link
            event.target.classList.add('active');
            
            // Close mobile menu if open
            document.getElementById('nav-menu').classList.remove('active');
        }

        function toggleMenu() {
            document.getElementById('nav-menu').classList.toggle('active');
        }

        // Quine-McCluskey functionality
        class QuineMcCluskey {
            constructor() {
                this.variables = 4;
                this.varNames = ['W', 'X', 'Y', 'Z'];
            }

            toBinary(num, bits) {
                return num.toString(2).padStart(bits, '0');
            }

            countOnes(binary) {
                return binary.split('1').length - 1;
            }

            canCombine(term1, term2) {
                let differences = 0;
                for (let i = 0; i < term1.length; i++) {
                    if (term1[i] !== term2[i]) {
                        differences++;
                        if (differences > 1) return false;
                    }
                }
                return differences === 1;
            }

            combine(term1, term2) {
                let result = '';
                for (let i = 0; i < term1.length; i++) {
                    if (term1[i] !== term2[i]) {
                        result += '-';
                    } else {
                        result += term1[i];
                    }
                }
                return result;
            }

            quineMcCluskey(minterms) {
                if (!minterms || minterms.length === 0) return [];

                let iterations = [];
                let currentTerms = new Map();
                
                for (let minterm of minterms) {
                    let binary = this.toBinary(minterm, this.variables);
                    currentTerms.set(binary, [minterm]);
                }

                let iterationNum = 1;
                
                while (true) {
                    let nextTerms = new Map();
                    let used = new Set();
                    let groups = new Map();
                    
                    for (let [term, origins] of currentTerms) {
                        let ones = this.countOnes(term);
                        if (!groups.has(ones)) {
                            groups.set(ones, []);
                        }
                        groups.get(ones).push({term, origins});
                    }
                    
                    let iterationData = {
                        iteration: iterationNum,
                        groups: [],
                        combinations: []
                    };
                    
                    for (let [ones, terms] of groups) {
                        iterationData.groups.push({
                            ones: ones,
                            terms: terms.map(t => ({
                                binary: t.term,
                                origins: t.origins
                            }))
                        });
                    }
                    
                    let sortedGroups = Array.from(groups.keys()).sort((a, b) => a - b);
                    for (let i = 0; i < sortedGroups.length - 1; i++) {
                        let group1 = groups.get(sortedGroups[i]);
                        let group2 = groups.get(sortedGroups[i + 1]);
                        
                        for (let term1 of group1) {
                            for (let term2 of group2) {
                                if (this.canCombine(term1.term, term2.term)) {
                                    let combined = this.combine(term1.term, term2.term);
                                    let newOrigins = [...new Set([...term1.origins, ...term2.origins])].sort((a, b) => a - b);
                                    
                                    nextTerms.set(combined, newOrigins);
                                    used.add(term1.term);
                                    used.add(term2.term);
                                    
                                    iterationData.combinations.push({
                                        term1: term1.term,
                                        term2: term2.term,
                                        result: combined,
                                        origins: newOrigins
                                    });
                                }
                            }
                        }
                    }
                    
                    iterations.push(iterationData);
                    
                    if (nextTerms.size === 0) break;
                    
                    for (let [term, origins] of currentTerms) {
                        if (!used.has(term)) {
                            nextTerms.set(term, origins);
                        }
                    }
                    
                    currentTerms = nextTerms;
                    iterationNum++;
                }
                
                let primeImplicants = [];
                for (let [term, origins] of currentTerms) {
                    primeImplicants.push({term, origins});
                }
                
                return {iterations, primeImplicants};
            }

            generateKMap(minterms) {
                let kmap = Array(4).fill().map(() => Array(4).fill(0));
                let grayCode = ['00', '01', '11', '10'];
                
                for (let minterm of minterms) {
                    let binary = this.toBinary(minterm, 4);
                    let wx = binary.substring(0, 2);
                    let yz = binary.substring(2, 4);
                    
                    let row = grayCode.indexOf(wx);
                    let col = grayCode.indexOf(yz);
                    
                    kmap[row][col] = 1;
                }
                
                return kmap;
            }

            petrickFunction(primeImplicants, minterms) {
                let coverageTable = [];
                
                for (let minterm of minterms) {
                    let coverage = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        let pi = primeImplicants[i];
                        coverage.push(pi.origins.includes(minterm) ? 1 : 0);
                    }
                    coverageTable.push({minterm, coverage});
                }
                
                let essentialPIs = new Set();
                let coveredMinterms = new Set();
                
                for (let row of coverageTable) {
                    let coveringPIs = [];
                    for (let i = 0; i < row.coverage.length; i++) {
                        if (row.coverage[i] === 1) {
                            coveringPIs.push(i);
                        }
                    }
                    if (coveringPIs.length === 1) {
                        essentialPIs.add(coveringPIs[0]);
                    }
                }
                
                for (let piIndex of essentialPIs) {
                    for (let minterm of primeImplicants[piIndex].origins) {
                        coveredMinterms.add(minterm);
                    }
                }
                
                let uncoveredMinterms = minterms.filter(m => !coveredMinterms.has(m));
                
                if (uncoveredMinterms.length === 0) {
                    return {
                        coverageTable, 
                        solution: Array.from(essentialPIs),
                        essentialPIs: Array.from(essentialPIs),
                        petrickExpression: "V≈°echny mintermy pokryt√© esenci√°ln√≠mi PI"
                    };
                }
                
                let bestSolution = this.findOptimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs);
                
                let petrickTerms = [];
                for (let minterm of uncoveredMinterms) {
                    let termPIs = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (primeImplicants[i].origins.includes(minterm) && !essentialPIs.has(i)) {
                            termPIs.push(`P${i}`);
                        }
                    }
                    if (termPIs.length > 0) {
                        petrickTerms.push(`(${termPIs.join(' + ')})`);
                    }
                }
                
                let petrickExpression = petrickTerms.length > 0 ? 
                    petrickTerms.join(' ¬∑ ') : 
                    "≈Ω√°dn√© dal≈°√≠ mintermy k pokryt√≠";
                
                return {
                    coverageTable, 
                    solution: bestSolution,
                    essentialPIs: Array.from(essentialPIs),
                    petrickExpression: petrickExpression
                };
            }

            findOptimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs) {
                if (uncoveredMinterms.length === 0) {
                    return Array.from(essentialPIs);
                }
                
                if (uncoveredMinterms.length <= 6) {
                    let candidatePIs = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (!essentialPIs.has(i)) {
                            for (let minterm of uncoveredMinterms) {
                                if (primeImplicants[i].origins.includes(minterm)) {
                                    candidatePIs.push(i);
                                    break;
                                }
                            }
                        }
                    }
                    
                    let bestSolution = null;
                    let bestCost = Infinity;
                    
                    for (let mask = 1; mask < (1 << candidatePIs.length); mask++) {
                        let currentSolution = Array.from(essentialPIs);
                        let covered = new Set();
                        
                        for (let piIndex of essentialPIs) {
                            for (let minterm of primeImplicants[piIndex].origins) {
                                covered.add(minterm);
                            }
                        }
                        
                        for (let i = 0; i < candidatePIs.length; i++) {
                            if (mask & (1 << i)) {
                                let piIndex = candidatePIs[i];
                                currentSolution.push(piIndex);
                                for (let minterm of primeImplicants[piIndex].origins) {
                                    covered.add(minterm);
                                }
                            }
                        }
                        
                        let allCovered = true;
                        for (let minterm of uncoveredMinterms) {
                            if (!covered.has(minterm)) {
                                allCovered = false;
                                break;
                            }
                        }
                        
                        if (allCovered) {
                            let cost = 0;
                            for (let piIndex of currentSolution) {
                                let term = primeImplicants[piIndex].term;
                                cost += term.length - (term.match(/-/g) || []).length;
                            }
                            
                            if (cost < bestCost) {
                                bestCost = cost;
                                bestSolution = currentSolution;
                            }
                        }
                    }
                    
                    if (bestSolution) {
                        return bestSolution;
                    }
                }
                
                return this.findMinimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs);
            }

            findMinimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs) {
                let solution = Array.from(essentialPIs);
                let remaining = new Set(uncoveredMinterms);
                
                while (remaining.size > 0) {
                    let bestPI = -1;
                    let bestCoverage = 0;
                    
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (solution.includes(i)) continue;
                        
                        let coverage = 0;
                        for (let minterm of primeImplicants[i].origins) {
                            if (remaining.has(minterm)) {
                                coverage++;
                            }
                        }
                        
                        if (coverage > bestCoverage) {
                            bestCoverage = coverage;
                            bestPI = i;
                        }
                    }
                    
                    if (bestPI === -1) break;
                    
                    solution.push(bestPI);
                    for (let minterm of primeImplicants[bestPI].origins) {
                        remaining.delete(minterm);
                    }
                }
                
                return solution;
            }

            termToAlgebraic(term) {
                let result = '';
                for (let i = 0; i < term.length; i++) {
                    if (term[i] !== '-') {
                        if (result !== '') result += '';
                        if (term[i] === '0') {
                            result += this.varNames[i] + "'";
                        } else {
                            result += this.varNames[i];
                        }
                    }
                }
                return result || '1';
            }
        }

        const qm = new QuineMcCluskey();

        function loadQMPreset(minterms) {
            document.getElementById('minterms').value = minterms;
            runQuineMcCluskey();
        }

        function runQuineMcCluskey() {
            try {
                let input = document.getElementById('minterms').value;
                let minterms = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
                
                if (minterms.length === 0) {
                    throw new Error('Zadejte platn√© mintermy');
                }
                
                let maxMinterm = Math.max(...minterms);
                if (maxMinterm >= 16) {
                    throw new Error('Mintermy mus√≠ b√Ωt v rozsahu 0-15 pro 4 promƒõnn√©');
                }
                
                let result = qm.quineMcCluskey(minterms);
                let petrickResult = qm.petrickFunction(result.primeImplicants, minterms);
                
                displayQMIterations(result.iterations);
                displayQMKMap(qm.generateKMap(minterms), minterms);
                displayQMPetrick(result.primeImplicants, petrickResult, minterms);
                
            } catch (error) {
                document.getElementById('qm-iterations').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
                document.getElementById('qm-kmap').innerHTML = '';
                document.getElementById('qm-petrick').innerHTML = '';
                document.getElementById('qm-coverage').innerHTML = '';
                document.getElementById('qm-final-result').innerHTML = '';
            }
        }

        function displayQMIterations(iterations) {
            let html = '';
            
            for (let iter of iterations) {
                html += `<h3>Iterace ${iter.iteration}</h3>`;
                
                if (iter.groups.length > 0) {
                    html += '<table class="iteration-table">';
                    html += '<tr><th>Poƒçet jedniƒçek</th><th>Bin√°rn√≠</th><th>Mintermy</th></tr>';
                    
                    for (let group of iter.groups) {
                        for (let term of group.terms) {
                            html += `<tr>`;
                            html += `<td>${group.ones}</td>`;
                            html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${term.binary}</td>`;
                            html += `<td>${term.origins.join(', ')}</td>`;
                            html += `</tr>`;
                        }
                    }
                    html += '</table>';
                }
                
                if (iter.combinations.length > 0) {
                    html += '<div class="step-explanation">Kombinace:</div>';
                    html += '<table class="iteration-table">';
                    html += '<tr><th>Term 1</th><th>Term 2</th><th>Kombinovan√Ω</th><th>Mintermy</th></tr>';
                    
                    for (let combo of iter.combinations) {
                        html += `<tr class="combined-term">`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.term1}</td>`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.term2}</td>`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.result}</td>`;
                        html += `<td>${combo.origins.join(', ')}</td>`;
                        html += `</tr>`;
                    }
                    html += '</table>';
                } else {
                    html += '<div class="step-explanation">≈Ω√°dn√© dal≈°√≠ kombinace mo≈æn√© - konec</div>';
                }
            }
            
            document.getElementById('qm-iterations').innerHTML = html;
        }

        function displayQMKMap(kmap, minterms) {
            let html = '<div class="kmap-container">';
            html += '<table class="kmap">';
            
            html += '<tr><th>WX\\YZ</th><th>00</th><th>01</th><th>11</th><th>10</th></tr>';
            
            let grayRows = ['00', '01', '11', '10'];
            
            for (let i = 0; i < 4; i++) {
                html += `<tr><th>${grayRows[i]}</th>`;
                for (let j = 0; j < 4; j++) {
                    let value = kmap[i][j];
                    let className = value === 1 ? 'one' : 'zero';
                    html += `<td class="${className}">${value}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</table>';
            html += '</div>';
            
            html += '<div class="step-explanation">ƒåerven√© bu≈àky = mintermy, ≈°ed√© = nepou≈æit√©</div>';
            
            document.getElementById('qm-kmap').innerHTML = html;
        }

        function displayQMPetrick(primeImplicants, petrickResult, minterms) {
            let html = '<h3>Prime implicanty:</h3>';
            html += '<table class="iteration-table">';
            html += '<tr><th>Index</th><th>Bin√°rn√≠</th><th>Algebraicky</th><th>Pokr√Ωv√° mintermy</th><th>Typ</th></tr>';
            
            for (let i = 0; i < primeImplicants.length; i++) {
                let pi = primeImplicants[i];
                let isEssential = petrickResult.essentialPIs.includes(i);
                let isUsed = petrickResult.solution.includes(i);
                let type = isEssential ? 'Esenci√°ln√≠' : (isUsed ? 'Pou≈æit√Ω' : 'Nepou≈æit√Ω');
                let rowClass = isEssential ? 'style="background: #e8f5e8 !important;"' : 
                              (isUsed ? 'style="background: #fff3cd !important;"' : '');
                
                html += `<tr ${rowClass}>`;
                html += `<td>P${i}</td>`;
                html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${pi.term}</td>`;
                html += `<td>${qm.termToAlgebraic(pi.term)}</td>`;
                html += `<td>${pi.origins.join(', ')}</td>`;
                html += `<td><strong>${type}</strong></td>`;
                html += `</tr>`;
            }
            html += '</table>';
            
            if (petrickResult.petrickExpression && petrickResult.petrickExpression !== "V≈°echny mintermy pokryt√© esenci√°ln√≠mi PI") {
                html += '<div class="step-explanation">';
                html += '<h4>Petrickova funkce pro nepokryt√© mintermy:</h4>';
                html += `<div style="font-family: monospace; font-size: 16px; padding: 10px; background: #f0f0f0; border-radius: 5px; color: #333;">`;
                html += `P = ${petrickResult.petrickExpression}</div>`;
                html += '</div>';
            }
            
            document.getElementById('qm-petrick').innerHTML = html;
            
            html = '<h3>Tabulka pokryt√≠:</h3>';
            html += '<table class="coverage-table">';
            html += '<tr><th>Minterm</th>';
            for (let i = 0; i < primeImplicants.length; i++) {
                let isUsed = petrickResult.solution.includes(i);
                let headerClass = isUsed ? 'style="background: #27ae60 !important;"' : '';
                html += `<th ${headerClass}>P${i}</th>`;
            }
            html += '</tr>';
            
            for (let row of petrickResult.coverageTable) {
                html += `<tr><td><strong>${row.minterm}</strong></td>`;
                for (let i = 0; i < row.coverage.length; i++) {
                    let className = row.coverage[i] === 1 ? 'covered' : '';
                    html += `<td class="${className}">${row.coverage[i] === 1 ? '‚úì' : ''}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            document.getElementById('qm-coverage').innerHTML = html;
            
            let selectedPIs = petrickResult.solution.map(i => qm.termToAlgebraic(primeImplicants[i].term));
            let finalExpression = selectedPIs.join(' + ');
            
            html = `<div class="final-result">`;
            html += `<h3>üéØ Minim√°ln√≠ v√Ωraz:</h3>`;
            html += `<div style="font-size: 24px; margin: 15px 0;">F = ${finalExpression}</div>`;
            html += `<div>Pou≈æit√© prime implicanty: ${petrickResult.solution.map(i => `P${i}`).join(', ')}</div>`;
            html += `<div style="margin-top: 10px;">Esenci√°ln√≠ PI: ${petrickResult.essentialPIs.map(i => `P${i}`).join(', ') || '≈æ√°dn√©'}</div>`;
            html += `<div>Celkem liter√°l≈Ø: ${selectedPIs.join('').replace(/[^A-Z']/g, '').length}</div>`;
            html += `</div>`;
            
            document.getElementById('qm-final-result').innerHTML = html;
        }

        // IEEE 754 functionality
        function loadIEEEExample(a, b) {
            document.getElementById('ieee-num1').value = a;
            document.getElementById('ieee-num2').value = b;
            calculateIEEE754Addition();
        }

        function floatToIEEE754(num) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setFloat32(0, num, false);
            const bits = view.getUint32(0, false);
            
            const binary = bits.toString(2).padStart(32, '0');
            const sign = binary[0];
            const exponent = binary.slice(1, 9);
            const mantissa = binary.slice(9);
            
            return {
                binary: binary,
                sign: sign,
                exponent: exponent,
                mantissa: mantissa,
                exponentValue: parseInt(exponent, 2),
                biasedExponent: parseInt(exponent, 2) - 127,
                mantissaValue: 1 + parseInt(mantissa, 2) / Math.pow(2, 23)
            };
        }

        function ieee754ToBinary(sign, exponent, mantissa) {
            return sign + exponent + mantissa;
        }

        function binaryToFloat(binary) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setUint32(0, parseInt(binary, 2), false);
            return view.getFloat32(0, false);
        }

        function addMantissas(m1, m2, expDiff) {
            const mantissa1 = Math.round((1 + parseInt(m1, 2) / Math.pow(2, 23)) * Math.pow(2, 23));
            let mantissa2 = Math.round((1 + parseInt(m2, 2) / Math.pow(2, 23)) * Math.pow(2, 23));
            
            mantissa2 = Math.round(mantissa2 / Math.pow(2, expDiff));
            
            const sum = mantissa1 + mantissa2;
            
            return {
                mantissa1: mantissa1,
                mantissa2: mantissa2,
                sum: sum,
                mantissa1Bin: (mantissa1).toString(2),
                mantissa2Bin: (mantissa2).toString(2),
                sumBin: sum.toString(2)
            };
        }

        function normalizeResult(sum, exponent) {
            let sumBin = sum.toString(2);
            let newExponent = exponent;
            
            if (sumBin.length > 24) {
                const shift = sumBin.length - 24;
                newExponent += shift;
                sumBin = sumBin.slice(0, 24);
            }
            
            let mantissa = sumBin.slice(1, 24).padEnd(23, '0');
            
            return {
                mantissa: mantissa,
                exponent: newExponent,
                exponentBin: (newExponent + 127).toString(2).padStart(8, '0')
            };
        }

        function calculateIEEE754Addition() {
            try {
                const num1 = parseFloat(document.getElementById('ieee-num1').value);
                const num2 = parseFloat(document.getElementById('ieee-num2').value);
                
                if (isNaN(num1) || isNaN(num2)) {
                    throw new Error('Zadejte platn√° ƒç√≠sla');
                }
                
                const ieee1 = floatToIEEE754(num1);
                const ieee2 = floatToIEEE754(num2);
                
                let html = '';
                
                html += `<div class="section">
                    <h2>Krok 1: IEEE 754 reprezentace ƒç√≠sel</h2>
                    <div class="info-box">
                        <strong>Struktura IEEE 754 (32-bit):</strong><br>
                        <span class="sign">S</span> = znam√©nko (1 bit), 
                        <span class="exponent">EEEEEEEE</span> = exponent + 127 (8 bit≈Ø), 
                        <span class="mantissa">MMMMMMMMMMMMMMMMMMMMMMM</span> = mantisa (23 bit≈Ø)
                    </div>
                    
                    <table class="table">
                        <tr><th>ƒå√≠slo</th><th>Desetinnƒõ</th><th>IEEE 754 Binary</th><th>Rozklad</th></tr>
                        <tr>
                            <td><strong>A</strong></td>
                            <td>${num1}</td>
                            <td class="binary-display">
                                <span class="sign">${ieee1.sign}</span>
                                <span class="exponent">${ieee1.exponent}</span>
                                <span class="mantissa">${ieee1.mantissa}</span>
                            </td>
                            <td>Exp: ${ieee1.exponentValue} (${ieee1.biasedExponent}+127)<br>
                                Mantisa: 1.${ieee1.mantissa} ‚âà ${ieee1.mantissaValue.toFixed(6)}</td>
                        </tr>
                        <tr>
                            <td><strong>B</strong></td>
                            <td>${num2}</td>
                            <td class="binary-display">
                                <span class="sign">${ieee2.sign}</span>
                                <span class="exponent">${ieee2.exponent}</span>
                                <span class="mantissa">${ieee2.mantissa}</span>
                            </td>
                            <td>Exp: ${ieee2.exponentValue} (${ieee2.biasedExponent}+127)<br>
                                Mantisa: 1.${ieee2.mantissa} ‚âà ${ieee2.mantissaValue.toFixed(6)}</td>
                        </tr>
                    </table>
                </div>`;
                
                const expDiff = Math.abs(ieee1.biasedExponent - ieee2.biasedExponent);
                const largerExp = Math.max(ieee1.biasedExponent, ieee2.biasedExponent);
                const isNum1Larger = ieee1.biasedExponent >= ieee2.biasedExponent;
                
                html += `<div class="section">
                    <h2>Krok 2: Srovn√°n√≠ exponent≈Ø</h2>
                    <div class="calculation-step">
                        <strong>Exponenty:</strong><br>
                        A: ${ieee1.biasedExponent} (${ieee1.exponent}‚ÇÇ)<br>
                        B: ${ieee2.biasedExponent} (${ieee2.exponent}‚ÇÇ)<br><br>
                        
                        <strong>Rozd√≠l exponent≈Ø:</strong> |${ieee1.biasedExponent} - ${ieee2.biasedExponent}| = ${expDiff}<br>
                        <strong>Vƒõt≈°√≠ exponent:</strong> ${largerExp}<br>
                        <strong>Men≈°√≠ mantisu je t≈ôeba posunout o ${expDiff} pozic doprava</strong>
                    </div>
                </div>`;
                
                let m1 = ieee1.mantissa;
                let m2 = ieee2.mantissa;
                let sign1 = ieee1.sign;
                let sign2 = ieee2.sign;
                
                if (!isNum1Larger) {
                    [m1, m2] = [m2, m1];
                    [sign1, sign2] = [sign2, sign1];
                }
                
                const mantissaCalc = addMantissas(m1, m2, expDiff);
                
                html += `<div class="section">
                    <h2>Krok 3: Posun mantisy a p≈ôevod na cel√° ƒç√≠sla</h2>
                    <div class="calculation-step">
                        <strong>Normalizovan√© mantisy (s implicitn√≠ 1):</strong><br>
                        Vƒõt≈°√≠ ƒç√≠slo: 1.${m1} ‚Üí ${mantissaCalc.mantissa1} (cel√© ƒç√≠slo)<br>
                        Men≈°√≠ ƒç√≠slo: 1.${m2} ‚Üí ${mantissaCalc.mantissa2} (posunut√© o ${expDiff})<br><br>
                        
                        <strong>Bin√°rnƒõ:</strong><br>
                        ${mantissaCalc.mantissa1Bin}‚ÇÇ<br>
                        ${mantissaCalc.mantissa2Bin}‚ÇÇ<br>
                        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>
                        ${mantissaCalc.sumBin}‚ÇÇ = ${mantissaCalc.sum}‚ÇÅ‚ÇÄ
                    </div>
                </div>`;
                
                const normalized = normalizeResult(mantissaCalc.sum, largerExp);
                
                html += `<div class="section">
                    <h2>Krok 4: Normalizace v√Ωsledku</h2>
                    <div class="calculation-step">
                        <strong>Suma mantis:</strong> ${mantissaCalc.sum} = ${mantissaCalc.sumBin}‚ÇÇ<br><br>
                        
                        <strong>Normalizace:</strong><br>
                        Exponent: ${normalized.exponent} ‚Üí ${normalized.exponent + 127} ‚Üí ${normalized.exponentBin}‚ÇÇ<br>
                        Mantisa: ${normalized.mantissa} (bez implicitn√≠ 1)
                    </div>
                </div>`;
                
                const resultSign = (num1 + num2) >= 0 ? '0' : '1';
                const resultBinary = ieee754ToBinary(resultSign, normalized.exponentBin, normalized.mantissa);
                const actualResult = num1 + num2;
                const calculatedResult = binaryToFloat(resultBinary);
                
                html += `<div class="section">
                    <h2>Krok 5: Fin√°ln√≠ v√Ωsledek</h2>
                    <div class="binary-display">
                        <span class="sign">${resultSign}</span>
                        <span class="exponent">${normalized.exponentBin}</span>
                        <span class="mantissa">${normalized.mantissa}</span>
                    </div>
                    
                    <div class="final-result">
                        <h3>üéØ V√Ωsledek sƒç√≠t√°n√≠:</h3>
                        <div style="font-size: 24px; margin: 15px 0;">${num1} + ${num2} = ${actualResult}</div>
                        <div>IEEE 754 v√Ωpoƒçet: ${calculatedResult.toFixed(6)}</div>
                        <div>P≈ôesnost: ${Math.abs(actualResult - calculatedResult) < 0.000001 ? '‚úÖ P≈ôesn√Ω' : '‚ö†Ô∏è Zaokrouhlen√≠'}</div>
                    </div>
                </div>`;
                
                document.getElementById('ieee-results').innerHTML = html;
                
            } catch (error) {
                document.getElementById('ieee-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
            }
        }

        // Binary arithmetic functionality
        function loadBinaryPreset(num1, num2, operation) {
            document.getElementById('bin-num1').value = num1;
            document.getElementById('bin-num2').value = num2;
            document.getElementById('bin-operation').value = operation;
            calculateBinaryArithmetic();
        }

        function parseBinaryInput(input) {
            // Pokud obsahuje jen 0 a 1, je to bin√°rn√≠
            if (/^[01]+$/.test(input)) {
                return {
                    binary: input.padStart(8, '0'),
                    decimal: parseInt(input, 2)
                };
            } else {
                // Jinak je to desetinn√© ƒç√≠slo
                let decimal = parseInt(input);
                return {
                    binary: decimal.toString(2).padStart(8, '0'),
                    decimal: decimal
                };
            }
        }

        function binaryAddition(a, b) {
            let result = '';
            let carry = 0;
            let steps = [];
            
            // Ujisti se, ≈æe maj√≠ stejnou d√©lku
            let maxLen = Math.max(a.length, b.length);
            a = a.padStart(maxLen, '0');
            b = b.padStart(maxLen, '0');
            
            for (let i = maxLen - 1; i >= 0; i--) {
                let bitA = parseInt(a[i]);
                let bitB = parseInt(b[i]);
                let sum = bitA + bitB + carry;
                
                steps.push({
                    position: maxLen - 1 - i,
                    bitA: bitA,
                    bitB: bitB,
                    carry: carry,
                    sum: sum,
                    result: sum % 2,
                    newCarry: Math.floor(sum / 2)
                });
                
                result = (sum % 2) + result;
                carry = Math.floor(sum / 2);
            }
            
            if (carry) {
                result = carry + result;
            }
            
            return { result, steps };
        }

        function binarySubtraction(a, b) {
            let steps = [];
            let result = '';
            let borrow = 0;
            
            let maxLen = Math.max(a.length, b.length);
            a = a.padStart(maxLen, '0');
            b = b.padStart(maxLen, '0');
            
            // Kontrola, zda a >= b
            if (parseInt(a, 2) < parseInt(b, 2)) {
                return {
                    result: 'Z√ÅPORN√ù V√ùSLEDEK',
                    steps: [],
                    note: 'Pro zjednodu≈°en√≠ ukazujeme jen kladn√© v√Ωsledky. V CPU by se pou≈æil dopl≈àkov√Ω k√≥d.'
                };
            }
            
            for (let i = maxLen - 1; i >= 0; i--) {
                let bitA = parseInt(a[i]) - borrow;
                let bitB = parseInt(b[i]);
                
                if (bitA < bitB) {
                    bitA += 2;
                    borrow = 1;
                } else {
                    borrow = 0;
                }
                
                let diff = bitA - bitB;
                
                steps.push({
                    position: maxLen - 1 - i,
                    originalA: parseInt(a[i]),
                    bitA: bitA,
                    bitB: bitB,
                    borrow: borrow,
                    result: diff
                });
                
                result = diff + result;
            }
            
            // Odstra≈à vedouc√≠ nuly
            result = result.replace(/^0+/, '') || '0';
            
            return { result, steps };
        }

        function binaryMultiplication(a, b) {
            let steps = [];
            let partialProducts = [];
            
            let decimalA = parseInt(a, 2);
            let decimalB = parseInt(b, 2);
            
            for (let i = b.length - 1; i >= 0; i--) {
                if (b[i] === '1') {
                    let shift = b.length - 1 - i;
                    let product = a + '0'.repeat(shift);
                    partialProducts.push({
                        multiplier: b[i],
                        shift: shift,
                        product: product,
                        position: i
                    });
                }
            }
            
            // Seƒçti v≈°echny ƒç√°steƒçn√© souƒçiny
            let finalResult = '0';
            for (let product of partialProducts) {
                let addition = binaryAddition(finalResult, product.product);
                finalResult = addition.result;
            }
            
            return {
                result: finalResult,
                partialProducts: partialProducts,
                decimalResult: decimalA * decimalB
            };
        }

        function binaryDivision(dividend, divisor) {
            let quotient = '';
            let remainder = '';
            let steps = [];
            
            let decimalDividend = parseInt(dividend, 2);
            let decimalDivisor = parseInt(divisor, 2);
            
            if (decimalDivisor === 0) {
                return { error: 'Dƒõlen√≠ nulou!' };
            }
            
            let currentDividend = '';
            
            for (let i = 0; i < dividend.length; i++) {
                currentDividend += dividend[i];
                let currentDecimal = parseInt(currentDividend, 2) || 0;
                
                if (currentDecimal >= decimalDivisor) {
                    quotient += '1';
                    let subtraction = (currentDecimal - decimalDivisor).toString(2);
                    remainder = subtraction;
                    currentDividend = remainder;
                    
                    steps.push({
                        step: i + 1,
                        currentDividend: currentDividend,
                        comparison: `${currentDecimal} >= ${decimalDivisor}`,
                        quotientBit: '1',
                        newRemainder: remainder
                    });
                } else {
                    quotient += '0';
                    steps.push({
                        step: i + 1,
                        currentDividend: currentDividend,
                        comparison: `${currentDecimal} < ${decimalDivisor}`,
                        quotientBit: '0',
                        newRemainder: currentDividend
                    });
                }
            }
            
            return {
                quotient: quotient.replace(/^0+/, '') || '0',
                remainder: remainder || '0',
                steps: steps,
                decimalQuotient: Math.floor(decimalDividend / decimalDivisor),
                decimalRemainder: decimalDividend % decimalDivisor
            };
        }

        function calculateBinaryArithmetic() {
            try {
                let input1 = document.getElementById('bin-num1').value.trim();
                let input2 = document.getElementById('bin-num2').value.trim();
                let operation = document.getElementById('bin-operation').value;
                
                if (!input1 || !input2) {
                    throw new Error('Zadejte obƒõ ƒç√≠sla');
                }
                
                let num1 = parseBinaryInput(input1);
                let num2 = parseBinaryInput(input2);
                
                let html = '';
                
                // Zobrazen√≠ vstupn√≠ch ƒç√≠sel
                html += `<div class="section">
                    <h2>Vstupn√≠ ƒç√≠sla</h2>
                    <table class="table">
                        <tr><th>ƒå√≠slo</th><th>Bin√°rnƒõ</th><th>Desetinnƒõ</th></tr>
                        <tr>
                            <td><strong>A</strong></td>
                            <td class="binary-display" style="font-size: 16px;">${num1.binary}</td>
                            <td>${num1.decimal}</td>
                        </tr>
                        <tr>
                            <td><strong>B</strong></td>
                            <td class="binary-display" style="font-size: 16px;">${num2.binary}</td>
                            <td>${num2.decimal}</td>
                        </tr>
                    </table>
                </div>`;
                
                // Proveden√≠ operace
                let result;
                switch (operation) {
                    case 'add':
                        result = binaryAddition(num1.binary, num2.binary);
                        html += displayAdditionSteps(num1, num2, result);
                        break;
                    case 'subtract':
                        result = binarySubtraction(num1.binary, num2.binary);
                        html += displaySubtractionSteps(num1, num2, result);
                        break;
                    case 'multiply':
                        result = binaryMultiplication(num1.binary, num2.binary);
                        html += displayMultiplicationSteps(num1, num2, result);
                        break;
                    case 'divide':
                        result = binaryDivision(num1.binary, num2.binary);
                        html += displayDivisionSteps(num1, num2, result);
                        break;
                    case 'non-restoring':
                        result = nonRestoringDivision(num1.binary, num2.binary);
                        html += displayNonRestoringSteps(num1, num2, result);
                        break;
                }
                
                document.getElementById('binary-results').innerHTML = html;
                
            } catch (error) {
                document.getElementById('binary-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
            }
        }

        function displayAdditionSteps(num1, num2, result) {
            let html = `<div class="section">
                <h2>üßÆ Sƒç√≠t√°n√≠ krok za krokem</h2>
                <div class="info-box">
                    <strong>Pravidla bin√°rn√≠ho sƒç√≠t√°n√≠:</strong><br>
                    0 + 0 = 0, &nbsp; 0 + 1 = 1, &nbsp; 1 + 0 = 1, &nbsp; 1 + 1 = 10 (p≈ôenos)
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;${num1.binary}<br>
                        + ${num2.binary}<br>
                        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>
                        ${result.result.padStart(Math.max(num1.binary.length, num2.binary.length) + 1, ' ')}
                    </div>
                </div>
                
                <h3>Postupn√© kroky:</h3>
                <table class="table">
                    <tr><th>Pozice</th><th>Bit A</th><th>Bit B</th><th>P≈ôenos</th><th>Souƒçet</th><th>V√Ωsledek</th><th>Nov√Ω p≈ôenos</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.position}</td>
                    <td>${step.bitA}</td>
                    <td>${step.bitB}</td>
                    <td>${step.carry}</td>
                    <td>${step.sum}</td>
                    <td><strong>${step.result}</strong></td>
                    <td>${step.newCarry}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>üéØ V√Ωsledek sƒç√≠t√°n√≠:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} + ${num2.decimal} = ${parseInt(result.result, 2)}</div>
                    <div>Bin√°rnƒõ: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displaySubtractionSteps(num1, num2, result) {
            if (result.note) {
                return `<div class="section">
                    <h2>‚ö†Ô∏è Odƒç√≠t√°n√≠</h2>
                    <div class="error">${result.note}</div>
                </div>`;
            }
            
            let html = `<div class="section">
                <h2>‚ûñ Odƒç√≠t√°n√≠ krok za krokem</h2>
                <div class="info-box">
                    <strong>Pravidla bin√°rn√≠ho odƒç√≠t√°n√≠:</strong><br>
                    0 - 0 = 0, &nbsp; 1 - 0 = 1, &nbsp; 1 - 1 = 0, &nbsp; 0 - 1 = 1 (s v√Ωp≈Øjƒçkou)
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;${num1.binary}<br>
                        - ${num2.binary}<br>
                        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>
                        &nbsp;&nbsp;${result.result.padStart(num1.binary.length, '0')}
                    </div>
                </div>
                
                <h3>Postupn√© kroky:</h3>
                <table class="table">
                    <tr><th>Pozice</th><th>P≈Øvodn√≠ A</th><th>A po v√Ωp≈Øjƒçce</th><th>B</th><th>V√Ωp≈Øjƒçka</th><th>Rozd√≠l</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.position}</td>
                    <td>${step.originalA}</td>
                    <td>${step.bitA}</td>
                    <td>${step.bitB}</td>
                    <td>${step.borrow}</td>
                    <td><strong>${step.result}</strong></td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>üéØ V√Ωsledek odƒç√≠t√°n√≠:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} - ${num2.decimal} = ${parseInt(result.result, 2)}</div>
                    <div>Bin√°rnƒõ: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displayMultiplicationSteps(num1, num2, result) {
            let html = `<div class="section">
                <h2>‚úñÔ∏è N√°soben√≠ krok za krokem</h2>
                <div class="info-box">
                    <strong>Bin√°rn√≠ n√°soben√≠:</strong><br>
                    Stejnƒõ jako v des√≠tkov√© soustavƒõ - n√°sob√≠me ka≈æd√Ωm bitem a posouv√°me pozice.
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;&nbsp;&nbsp;${num1.binary}<br>
                        √ó&nbsp;&nbsp;&nbsp;&nbsp;${num2.binary}<br>
                        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>`;
            
            for (let product of result.partialProducts) {
                html += `&nbsp;&nbsp;${product.product}<br>`;
            }
            
            html += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>`;
            html += `&nbsp;&nbsp;${result.result}<br>`;
            html += `</div></div>`;
            
            html += `<h3>ƒå√°steƒçn√© souƒçiny:</h3>
                <table class="table">
                    <tr><th>Bit n√°sobitele</th><th>Posun</th><th>ƒå√°steƒçn√Ω souƒçin</th></tr>`;
            
            for (let product of result.partialProducts) {
                html += `<tr>
                    <td>${product.multiplier} (pozice ${product.position})</td>
                    <td>${product.shift} pozic vlevo</td>
                    <td class="binary-display" style="font-size: 14px;">${product.product}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>üéØ V√Ωsledek n√°soben√≠:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} √ó ${num2.decimal} = ${result.decimalResult}</div>
                    <div>Bin√°rnƒõ: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displayDivisionSteps(num1, num2, result) {
            if (result.error) {
                return `<div class="section">
                    <h2>‚ö†Ô∏è Dƒõlen√≠</h2>
                    <div class="error">${result.error}</div>
                </div>`;
            }
            
            let html = `<div class="section">
                <h2>‚ûó Dƒõlen√≠ krok za krokem</h2>
                <div class="info-box">
                    <strong>Bin√°rn√≠ dƒõlen√≠:</strong><br>
                    Podobn√© dlouh√©mu dƒõlen√≠ - porovn√°v√°me a odƒç√≠t√°me postupnƒõ.
                </div>
                
                <h3>Postupn√© kroky:</h3>
                <table class="table">
                    <tr><th>Krok</th><th>Aktu√°ln√≠ dƒõlenec</th><th>Porovn√°n√≠</th><th>Bit pod√≠lu</th><th>Zbytek</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.step}</td>
                    <td class="binary-display" style="font-size: 14px;">${step.currentDividend}</td>
                    <td>${step.comparison}</td>
                    <td><strong>${step.quotientBit}</strong></td>
                    <td>${step.newRemainder}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>üéØ V√Ωsledek dƒõlen√≠:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} √∑ ${num2.decimal} = ${result.decimalQuotient} se zbytkem ${result.decimalRemainder}</div>
                    <div>Pod√≠l bin√°rnƒõ: ${result.quotient}</div>
                    <div>Zbytek bin√°rnƒõ: ${result.remainder}</div>
                </div>
            </div>`;
            
            return html;
        }
        function nonRestoringDivision(dividend, divisor) {
                let decimalDividend = parseInt(dividend, 2);
                let decimalDivisor = parseInt(divisor, 2);
                
                if (decimalDivisor === 0) {
                    return { error: 'Dƒõlen√≠ nulou!' };
                }
                
                let n = dividend.length;
                let A = 0; // Akumul√°tor
                let Q = decimalDividend; // Kvocient
                let M = decimalDivisor; // Dƒõlitel
                let quotient = '';
                let steps = [];
                
                for (let i = 0; i < n; i++) {
                    let stepData = {
                        step: i + 1,
                        initialA: A,
                        initialQ: Q.toString(2).padStart(n, '0'),
                        operation: '',
                        newA: 0,
                        newQ: '',
                        quotientBit: '',
                        description: ''
                    };
                    
                    // 1. Posun AQ doleva (kromƒõ prvn√≠ho kroku)
                    if (i > 0) {
                        let qMSB = Math.floor(Q / Math.pow(2, n-1));
                        A = (A * 2) + qMSB;
                        Q = (Q * 2) % Math.pow(2, n);
                    }
                    
                    // 2. Operace podle znam√©nka A
                    let newA;
                    if (A >= 0) {
                        newA = A - M;
                        stepData.operation = `${A} - ${M} = ${newA}`;
                        stepData.description = 'Posun + odeƒçten√≠ dƒõlitele';
                    } else {
                        newA = A + M;
                        stepData.operation = `${A} + ${M} = ${newA}`;
                        stepData.description = 'Posun + p≈ôiƒçten√≠ dƒõlitele';
                    }
                    
                    A = newA;
                    
                    // 3. Urƒçen√≠ bitu kvocientu
                    if (A >= 0) {
                        quotient += '1';
                        stepData.quotientBit = '1';
                        Q = Q | 1;
                        stepData.description += ' ‚Üí bit 1 (A ‚â• 0)';
                    } else {
                        quotient += '0';
                        stepData.quotientBit = '0';
                        Q = Q & ~1;
                        stepData.description += ' ‚Üí bit 0 (A < 0)';
                    }
                    
                    stepData.newA = A;
                    stepData.newQ = Q.toString(2).padStart(n, '0');
                    
                    steps.push(stepData);
                }
                
                // Korekce zbytku pokud je z√°porn√Ω
                if (A < 0) {
                    A = A + M;
                    steps.push({
                        step: 'Korekce',
                        description: 'P≈ôiƒçten√≠ dƒõlitele k z√°porn√©mu zbytku',
                        operation: `${A - M} + ${M} = ${A}`,
                        finalCorrection: true
                    });
                }
                
                return {
                    quotient: quotient.replace(/^0+/, '') || '0',
                    remainder: Math.abs(A).toString(2),
                    steps: steps,
                    decimalQuotient: Math.floor(decimalDividend / decimalDivisor),
                    decimalRemainder: decimalDividend % decimalDivisor,
                    algorithm: 'non-restoring'
                };
            }
            
            function displayNonRestoringSteps(num1, num2, result) {
                if (result.error) {
                    return `<div class="section">
                        <h2>‚ö†Ô∏è Dƒõlen√≠ bez restaurace</h2>
                        <div class="error">${result.error}</div>
                    </div>`;
                }
                
                let html = `<div class="section">
                    <h2>üîÑ Dƒõlen√≠ bez restaurace zbytku</h2>
                    <div class="info-box">
                        <strong>Algoritmus bez restaurace:</strong><br>
                        a) Odeƒçti dƒõlitel od akumul√°toru<br>
                        b) Na z√°kladƒõ MSB urƒçi bit kvocientu (MSB=0 ‚Üí bit 1, MSB=1 ‚Üí bit 0)<br>
                        c) Posu≈à AQ doleva (√ó2), MSB se zahod√≠<br>
                        d) Pokud je v√Ωsledek z√°porn√Ω, pokraƒçuj (bez restaurace)<br>
                        e) Opakuj dokud nen√≠ dosa≈æen maxim√°ln√≠ posun<br>
                        f) Na konci m≈Ø≈æe b√Ωt nutn√° korekce zbytku
                    </div>
                    
                    <div class="calculation-step">
                        <strong>Inicializace:</strong><br>
                        A (akumul√°tor): ${'0'.repeat(num1.binary.length)}<br>
                        Q (kvocient): ${num1.binary}<br>
                        M (dƒõlitel): ${num2.binary}
                    </div>
                    
                    <h3>Postupn√© kroky:</h3>
                    <table class="table">
                        <tr>
                            <th>Krok</th>
                            <th>Operace</th>
                            <th>Nov√Ω A</th>
                            <th>Nov√Ω Q</th>
                            <th>Q bit</th>
                            <th>Popis</th>
                        </tr>`;
                
                for (let step of result.steps) {
                    if (step.finalCorrection) {
                        html += `<tr style="background: #fff3cd;">
                            <td><strong>Korekce</strong></td>
                            <td>${step.operation}</td>
                            <td colspan="3">Fin√°ln√≠ korekce zbytku</td>
                            <td>${step.description}</td>
                        </tr>`;
                    } else {
                        html += `<tr>
                            <td>${step.step}</td>
                            <td>${step.operation}</td>
                            <td class="binary-display" style="font-size: 12px; padding: 4px;">${step.newA}</td>
                            <td class="binary-display" style="font-size: 12px; padding: 4px;">${step.newQ}</td>
                            <td><strong>${step.quotientBit}</strong></td>
                            <td style="font-size: 12px;">${step.description}</td>
                        </tr>`;
                    }
                }
                
                html += `</table>
                    
                    <div class="calculation-step">
                        <strong>V√Ωhody algoritmu bez restaurace:</strong><br>
                        ‚Ä¢ Rychlej≈°√≠ ne≈æ klasick√© dƒõlen√≠ (m√©nƒõ operac√≠)<br>
                        ‚Ä¢ Nemus√≠me vracet (restaurovat) z√°porn√© meziv√Ωsledky<br>
                        ‚Ä¢ Vhodn√Ω pro hardware implementaci<br>
                        ‚Ä¢ Pou≈æ√≠v√° se v modern√≠ch procesorech
                    </div>
                    
                    <div class="final-result">
                        <h3>üéØ V√Ωsledek dƒõlen√≠ bez restaurace:</h3>
                        <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} √∑ ${num2.decimal} = ${result.decimalQuotient} se zbytkem ${result.decimalRemainder}</div>
                        <div>Pod√≠l bin√°rnƒõ: ${result.quotient}</div>
                        <div>Zbytek bin√°rnƒõ: ${result.remainder}</div>
                        <div style="margin-top: 10px; font-size: 14px;">
                            <strong>Efektivita:</strong> Algoritmus bez restaurace je rychlej≈°√≠ ne≈æ klasick√© dƒõlen√≠
                        </div>
                    </div>
                </div>`;
                
                return html;
            }

        // IEEE 754 Converter functionality
function loadConverterExample(input, type) {
    document.getElementById('converter-input').value = input;
    document.getElementById('converter-type').value = type;
    convertIEEE754();
}

function decimalToIEEE754Detailed(num) {
    if (num === 0) {
        return {
            sign: '0',
            exponent: '00000000',
            mantissa: '00000000000000000000000',
            steps: ['Speci√°ln√≠ p≈ô√≠pad: nula m√° v≈°echny bity nastaven√© na 0'],
            isSpecial: true,
            value: 0
        };
    }
    
    let steps = [];
    let sign = num < 0 ? '1' : '0';
    let absNum = Math.abs(num);
    
    steps.push(`1. Urƒçen√≠ znam√©nka: ${num} ${num < 0 ? '< 0' : '‚â• 0'} ‚Üí S = ${sign}`);
    
    // P≈ôevod na bin√°rn√≠
    let intPart = Math.floor(absNum);
    let fracPart = absNum - intPart;
    
    let intBinary = intPart.toString(2);
    let fracBinary = '';
    
    steps.push(`2. Absolutn√≠ hodnota: |${num}| = ${absNum}`);
    steps.push(`3. Cel√° ƒç√°st: ${intPart} = ${intBinary}‚ÇÇ`);
    
    // P≈ôevod zlomkov√© ƒç√°sti
    let fracSteps = [];
    for (let i = 0; i < 23 && fracPart > 0; i++) {
        fracPart *= 2;
        if (fracPart >= 1) {
            fracBinary += '1';
            fracPart -= 1;
            fracSteps.push(`${(fracPart + 1).toFixed(6)} √ó 2 = ${(2 * (fracPart + 1)).toFixed(6)} ‚Üí 1`);
        } else {
            fracBinary += '0';
            fracSteps.push(`${fracPart.toFixed(6)} √ó 2 = ${(2 * fracPart).toFixed(6)} ‚Üí 0`);
        }
    }
    
    if (fracSteps.length > 0) {
        steps.push(`4. Zlomkov√° ƒç√°st: 0.${(absNum - intPart).toString().substring(2)}`);
        steps = steps.concat(fracSteps);
        steps.push(`   V√Ωsledek: 0.${fracBinary}`);
    }
    
    let fullBinary = intBinary + '.' + fracBinary;
    steps.push(`5. √öpln√Ω bin√°rn√≠ z√°pis: ${fullBinary}`);
    
    // Normalizace
    let decimalPos = fullBinary.indexOf('.');
    let firstOnePos = fullBinary.indexOf('1');
    
    if (firstOnePos === -1) {
        // Nula
        return {
            sign: '0',
            exponent: '00000000',
            mantissa: '00000000000000000000000',
            steps: steps.concat(['Speci√°ln√≠ p≈ô√≠pad: nula']),
            isSpecial: true,
            value: 0
        };
    }
    
    let exponentValue;
    let normalizedMantissa;
    
    if (firstOnePos < decimalPos) {
        // ƒå√≠slo ‚â• 1
        exponentValue = decimalPos - firstOnePos - 1;
        normalizedMantissa = fullBinary.substring(firstOnePos + 1).replace('.', '');
        steps.push(`6. Normalizace: 1.${normalizedMantissa} √ó 2^${exponentValue}`);
    } else {
        // ƒå√≠slo < 1
        exponentValue = -(firstOnePos - decimalPos);
        normalizedMantissa = fullBinary.substring(firstOnePos + 1);
        steps.push(`6. Normalizace: 1.${normalizedMantissa} √ó 2^${exponentValue}`);
    }
    
    // Bias
    let biasedExponent = exponentValue + 127;
    let exponentBinary = biasedExponent.toString(2).padStart(8, '0');
    
    steps.push(`7. Bias exponent: ${exponentValue} + 127 = ${biasedExponent} = ${exponentBinary}‚ÇÇ`);
    
    // Mantissa
    let mantissaBinary = normalizedMantissa.padEnd(23, '0').substring(0, 23);
    steps.push(`8. Mantissa (23 bit≈Ø): ${mantissaBinary}`);
    
    return {
        sign: sign,
        exponent: exponentBinary,
        mantissa: mantissaBinary,
        steps: steps,
        biasedExponent: biasedExponent,
        exponentValue: exponentValue,
        normalizedMantissa: normalizedMantissa
    };
}

function ieee754ToDecimalDetailed(binaryStr) {
    if (binaryStr.length !== 32) {
        throw new Error('IEEE 754 mus√≠ m√≠t p≈ôesnƒõ 32 bit≈Ø');
    }
    
    let steps = [];
    let sign = binaryStr[0];
    let exponent = binaryStr.substring(1, 9);
    let mantissa = binaryStr.substring(9);
    
    steps.push(`1. Rozklad IEEE 754:`);
    steps.push(`   Znam√©nko (S): ${sign}`);
    steps.push(`   Exponent (E): ${exponent}`);
    steps.push(`   Mantissa (M): ${mantissa}`);
    
    let exponentValue = parseInt(exponent, 2);
    steps.push(`2. Exponent v des√≠tkov√©: ${exponent}‚ÇÇ = ${exponentValue}‚ÇÅ‚ÇÄ`);
    
    // Speci√°ln√≠ p≈ô√≠pady
    if (exponentValue === 0) {
        if (parseInt(mantissa, 2) === 0) {
            steps.push(`3. Speci√°ln√≠ p≈ô√≠pad: exponent = 0, mantissa = 0 ‚Üí ${sign === '1' ? '-' : '+'}0`);
            return {
                value: sign === '1' ? -0 : 0,
                steps: steps,
                isSpecial: true
            };
        } else {
            steps.push(`3. Denormalizovan√© ƒç√≠slo (subnormal)`);
            let mantissaValue = parseInt(mantissa, 2) / Math.pow(2, 23);
            let result = Math.pow(-1, parseInt(sign)) * mantissaValue * Math.pow(2, -126);
            steps.push(`4. Hodnota: (-1)^${sign} √ó 0.${mantissa} √ó 2^(-126) = ${result}`);
            return {
                value: result,
                steps: steps,
                isSubnormal: true
            };
        }
    }
    
    if (exponentValue === 255) {
        if (parseInt(mantissa, 2) === 0) {
            steps.push(`3. Speci√°ln√≠ p≈ô√≠pad: ¬±‚àû`);
            return {
                value: sign === '1' ? -Infinity : Infinity,
                steps: steps,
                isSpecial: true
            };
        } else {
            steps.push(`3. Speci√°ln√≠ p≈ô√≠pad: NaN (Not a Number)`);
            return {
                value: NaN,
                steps: steps,
                isSpecial: true
            };
        }
    }
    
    // Norm√°ln√≠ ƒç√≠slo
    let realExponent = exponentValue - 127;
    steps.push(`3. Skuteƒçn√Ω exponent: ${exponentValue} - 127 = ${realExponent}`);
    
    let mantissaValue = 1 + parseInt(mantissa, 2) / Math.pow(2, 23);
    steps.push(`4. Mantissa s implicitn√≠ 1: 1.${mantissa}‚ÇÇ = ${mantissaValue.toFixed(8)}`);
    
    let result = Math.pow(-1, parseInt(sign)) * mantissaValue * Math.pow(2, realExponent);
    steps.push(`5. Fin√°ln√≠ v√Ωpoƒçet: (-1)^${sign} √ó ${mantissaValue.toFixed(8)} √ó 2^${realExponent} = ${result}`);
    
    return {
        value: result,
        steps: steps,
        sign: sign,
        exponent: exponent,
        mantissa: mantissa,
        realExponent: realExponent,
        mantissaValue: mantissaValue
    };
}

function convertIEEE754() {
    try {
        let input = document.getElementById('converter-input').value.trim();
        let type = document.getElementById('converter-type').value;
        
        if (!input) {
            throw new Error('Zadejte vstupn√≠ hodnotu');
        }
        
        let html = '';
        
        if (type === 'decimal') {
            // Desetinn√© ‚Üí IEEE 754
            let num = parseFloat(input);
            if (isNaN(num)) {
                throw new Error('Zadejte platn√© desetinn√© ƒç√≠slo');
            }
            
            let result = decimalToIEEE754Detailed(num);
            let fullBinary = result.sign + result.exponent + result.mantissa;
            
            html += `<div class="section">
                <h2>üî¢ P≈ôevod ${num} ‚Üí IEEE 754</h2>
                
                <div class="info-box">
                    <strong>C√≠l:</strong> P≈ôev√©st desetinn√© ƒç√≠slo ${num} na IEEE 754 (32-bit) bin√°rn√≠ reprezentaci
                </div>
                
                <h3>Krok za krokem:</h3>
                <div class="calculation-step">`;
            
            for (let step of result.steps) {
                html += `<div style="margin: 5px 0;">${step}</div>`;
            }
            
            html += `</div>
                
                <div class="binary-display">
                    <div style="text-align: center; margin: 20px 0;">
                        <span class="sign">${result.sign}</span>
                        <span class="exponent">${result.exponent}</span>
                        <span class="mantissa">${result.mantissa}</span>
                    </div>
                </div>
                
                <table class="table">
                    <tr><th>ƒå√°st</th><th>Bin√°rnƒõ</th><th>Hodnota</th><th>Popis</th></tr>
                    <tr>
                        <td><strong>Znam√©nko</strong></td>
                        <td class="sign">${result.sign}</td>
                        <td>${result.sign === '1' ? 'Z√°porn√©' : 'Kladn√©'}</td>
                        <td>1 bit</td>
                    </tr>
                    <tr>
                        <td><strong>Exponent</strong></td>
                        <td class="exponent">${result.exponent}</td>
                        <td>${result.biasedExponent || 0} (bias ${result.exponentValue || 0}+127)</td>
                        <td>8 bit≈Ø</td>
                    </tr>
                    <tr>
                        <td><strong>Mantissa</strong></td>
                        <td class="mantissa">${result.mantissa}</td>
                        <td>1.${result.normalizedMantissa || result.mantissa}</td>
                        <td>23 bit≈Ø</td>
                    </tr>
                </table>
                
                <div class="final-result">
                    <h3>üéØ V√Ωsledek:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">IEEE 754: ${fullBinary}</div>
                    <div>Hexadecim√°lnƒõ: 0x${parseInt(fullBinary, 2).toString(16).toUpperCase().padStart(8, '0')}</div>
                </div>
            </div>`;
            
        } else {
            // IEEE 754 ‚Üí Desetinn√©
            if (!/^[01]{32}$/.test(input)) {
                throw new Error('Zadejte platn√Ω 32-bitov√Ω bin√°rn√≠ ≈ôetƒõzec (pouze 0 a 1)');
            }
            
            let result = ieee754ToDecimalDetailed(input);
            
            html += `<div class="section">
                <h2>üî¢ P≈ôevod IEEE 754 ‚Üí Desetinn√©</h2>
                
                <div class="info-box">
                    <strong>C√≠l:</strong> P≈ôev√©st IEEE 754 bin√°rn√≠ reprezentaci na desetinn√© ƒç√≠slo
                </div>
                
                <div class="binary-display">
                    <div style="text-align: center; margin: 20px 0;">
                        <span class="sign">${input[0]}</span>
                        <span class="exponent">${input.substring(1, 9)}</span>
                        <span class="mantissa">${input.substring(9)}</span>
                    </div>
                </div>
                
                <h3>Krok za krokem:</h3>
                <div class="calculation-step">`;
            
            for (let step of result.steps) {
                html += `<div style="margin: 5px 0;">${step}</div>`;
            }
            
            html += `</div>`;
            
            if (!result.isSpecial && !result.isSubnormal) {
                html += `<table class="table">
                    <tr><th>ƒå√°st</th><th>Bin√°rnƒõ</th><th>Hodnota</th><th>V√Ωpoƒçet</th></tr>
                    <tr>
                        <td><strong>Znam√©nko</strong></td>
                        <td class="sign">${result.sign}</td>
                        <td>${result.sign === '1' ? '-1' : '+1'}</td>
                        <td>(-1)^${result.sign}</td>
                    </tr>
                    <tr>
                        <td><strong>Exponent</strong></td>
                        <td class="exponent">${result.exponent}</td>
                        <td>2^${result.realExponent}</td>
                        <td>${parseInt(result.exponent, 2)} - 127 = ${result.realExponent}</td>
                    </tr>
                    <tr>
                        <td><strong>Mantissa</strong></td>
                        <td class="mantissa">${result.mantissa}</td>
                        <td>${result.mantissaValue.toFixed(8)}</td>
                        <td>1 + ${parseInt(result.mantissa, 2)}/2^23</td>
                    </tr>
                </table>`;
            }
            
            html += `<div class="final-result">
                <h3>üéØ V√Ωsledek:</h3>
                <div style="font-size: 24px; margin: 15px 0;">Desetinnƒõ: ${result.value}</div>
                <div>Typ: ${result.isSpecial ? 'Speci√°ln√≠ hodnota' : result.isSubnormal ? 'Denormalizovan√© ƒç√≠slo' : 'Norm√°ln√≠ ƒç√≠slo'}</div>
            </div>
        </div>`;
        }
        
        document.getElementById('converter-results').innerHTML = html;
        
    } catch (error) {
        document.getElementById('converter-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
    }
}

// IEEE 754 Multiplication functionality
        function loadIEEEMultExample(a, b) {
            document.getElementById('ieee-mult-num1').value = a;
            document.getElementById('ieee-mult-num2').value = b;
            calculateIEEE754Multiplication();
        }

        function multiplyMantissasBinary(m1, m2) {
            // P≈ôevod mantis na desetinn√° ƒç√≠sla s implicitn√≠ 1
            const mantissa1 = 1 + parseInt(m1, 2) / Math.pow(2, 23);
            const mantissa2 = 1 + parseInt(m2, 2) / Math.pow(2, 23);
            
            const product = mantissa1 * mantissa2;
            
            // P≈ôevod produktu zpƒõt na bin√°rn√≠ reprezentaci
            let intPart = Math.floor(product);
            let fracPart = product - intPart;
            
            let intBinary = intPart.toString(2);
            let fracBinary = '';
            
            // P≈ôevod zlomkov√© ƒç√°sti na bin√°rn√≠
            for (let i = 0; i < 24 && fracPart > 0; i++) {
                fracPart *= 2;
                if (fracPart >= 1) {
                    fracBinary += '1';
                    fracPart -= 1;
                } else {
                    fracBinary += '0';
                }
            }
            
            return {
                mantissa1: mantissa1,
                mantissa2: mantissa2,
                product: product,
                intBinary: intBinary,
                fracBinary: fracBinary,
                fullBinary: intBinary + '.' + fracBinary,
                mantissa1Str: `1.${m1}`,
                mantissa2Str: `1.${m2}`
            };
        }

        function normalizeMultiplicationProduct(productValue, exponentSum) {
            let intPart = Math.floor(productValue);
            let fracPart = productValue - intPart;
            
            // P≈ôevod na bin√°rn√≠
            let intBinary = intPart.toString(2);
            let fracBinary = '';
            
            for (let i = 0; i < 24 && fracPart > 0; i++) {
                fracPart *= 2;
                if (fracPart >= 1) {
                    fracBinary += '1';
                    fracPart -= 1;
                } else {
                    fracBinary += '0';
                }
            }
            
            let fullBinary = intBinary + '.' + fracBinary;
            let firstOnePos = fullBinary.indexOf('1');
            let decimalPos = fullBinary.indexOf('.');
            
            let newExponent = exponentSum;
            let mantissa = '';
            let shift = 0;
            
            if (firstOnePos < decimalPos) {
                // ƒå√≠slo >= 2, posun doprava
                shift = decimalPos - firstOnePos - 1;
                newExponent += shift;
                mantissa = fullBinary.substring(firstOnePos + 1).replace('.', '');
            } else {
                // ƒå√≠slo < 2
                mantissa = fullBinary.substring(firstOnePos + 1);
                if (firstOnePos > decimalPos) {
                    shift = -(firstOnePos - decimalPos);
                    newExponent += shift;
                }
            }
            
            // O≈ô√≠zni na 23 bit≈Ø
            mantissa = mantissa.padEnd(23, '0').substring(0, 23);
            
            return {
                newExponent: newExponent,
                mantissa: mantissa,
                exponentBin: (newExponent + 127).toString(2).padStart(8, '0'),
                shift: shift,
                fullBinary: fullBinary,
                biasedExponent: newExponent + 127
            };
        }

        function calculateIEEE754Multiplication() {
            try {
                const num1 = parseFloat(document.getElementById('ieee-mult-num1').value);
                const num2 = parseFloat(document.getElementById('ieee-mult-num2').value);
                
                if (isNaN(num1) || isNaN(num2)) {
                    throw new Error('Zadejte platn√° ƒç√≠sla');
                }
                
                const ieee1 = floatToIEEE754(num1);
                const ieee2 = floatToIEEE754(num2);
                
                let html = '';
                
                // Zobrazen√≠ vstupn√≠ch ƒç√≠sel podle vzoru z obr√°zku
                html += `<div class="section">
                    <h2>Vstupn√≠ ƒç√≠sla v IEEE 754 form√°tu</h2>
                    <div class="info-box">
                        <strong>Vzorec IEEE 754 n√°soben√≠:</strong><br>
                        X ¬∑ Y = (X<sub>s</sub> ¬∑ Y<sub>s</sub>) ¬∑ 2<sup>X<sub>E</sub> + Y<sub>E</sub></sup><br>
                        kde X<sub>s</sub>, Y<sub>s</sub> jsou mantisy a X<sub>E</sub>, Y<sub>E</sub> jsou exponenty
                    </div>
                    
                    <div class="formula-display">
                        X = ${num1} = ${ieee1.binary.substring(9, 32)}<sub>2</sub> = 1.${ieee1.mantissa}<sub>2</sub> √ó 2<sup>${ieee1.biasedExponent}</sup>
                    </div>
                    
                    <div class="binary-display">
                        X: <span class="sign">${ieee1.sign}</span> | <span class="exponent">${ieee1.exponent}</span> | <span class="mantissa">${ieee1.mantissa}</span>
                    </div>
                    
                    <div class="formula-display">
                        Y = ${num2} = ${ieee2.binary.substring(9, 32)}<sub>2</sub> = 1.${ieee2.mantissa}<sub>2</sub> √ó 2<sup>${ieee2.biasedExponent}</sup>
                    </div>
                    
                    <div class="binary-display">
                        Y: <span class="sign">${ieee2.sign}</span> | <span class="exponent">${ieee2.exponent}</span> | <span class="mantissa">${ieee2.mantissa}</span>
                    </div>
                    
                    <table class="table">
                        <tr><th>ƒå√≠slo</th><th>Znam√©nko</th><th>Exponent (biased)</th><th>Exponent (skuteƒçn√Ω)</th><th>Mantissa</th></tr>
                        <tr>
                            <td><strong>X = ${num1}</strong></td>
                            <td>${ieee1.sign}</td>
                            <td>${ieee1.exponentValue}</td>
                            <td>X<sub>E</sub> = ${ieee1.biasedExponent}</td>
                            <td>X<sub>s</sub> = 1.${ieee1.mantissa}</td>
                        </tr>
                        <tr>
                            <td><strong>Y = ${num2}</strong></td>
                            <td>${ieee2.sign}</td>
                            <td>${ieee2.exponentValue}</td>
                            <td>Y<sub>E</sub> = ${ieee2.biasedExponent}</td>
                            <td>Y<sub>s</sub> = 1.${ieee2.mantissa}</td>
                        </tr>
                    </table>
                </div>`;
                
                // Krok 1: XOR znam√©nek
                const resultSign = ieee1.sign !== ieee2.sign ? '1' : '0';
                html += `<div class="section">
                    <h2>Krok 1: Urƒçen√≠ znam√©nka v√Ωsledku (XOR)</h2>
                    <div class="calculation-step">
                        <strong>XOR znam√©nek:</strong><br>
                        ${ieee1.sign} ‚äï ${ieee2.sign} = ${resultSign}<br><br>
                        
                        <div class="step-highlight">
                            V√Ωsledn√© znam√©nko: <strong>${resultSign}</strong> 
                            (${resultSign === '1' ? 'z√°porn√©' : 'kladn√©'})
                        </div>
                    </div>
                </div>`;
                
                // Krok 2: Sƒç√≠t√°n√≠ exponent≈Ø
                const exponentSum = ieee1.biasedExponent + ieee2.biasedExponent;
                html += `<div class="section">
                    <h2>Krok 2: Sƒç√≠t√°n√≠ exponent≈Ø</h2>
                    <div class="calculation-step">
                        <strong>Sƒç√≠t√°n√≠ skuteƒçn√Ωch exponent≈Ø:</strong><br>
                        X<sub>E</sub> + Y<sub>E</sub> = ${ieee1.biasedExponent} + ${ieee2.biasedExponent} = ${exponentSum}<br><br>
                        
                        <div class="step-highlight">
                            Souƒçet exponent≈Ø: <strong>${exponentSum}</strong>
                        </div>
                        
                        <div class="info-box">
                            <strong>Pozn√°mka:</strong> Bias (127) se automaticky p≈ôiƒçte pozdƒõji p≈ôi konverzi zpƒõt na IEEE 754 form√°t.
                        </div>
                    </div>
                </div>`;
                
                // Krok 3: N√°soben√≠ mantis
                const mantissaResult = multiplyMantissasBinary(ieee1.mantissa, ieee2.mantissa);
                html += `<div class="section">
                    <h2>Krok 3: N√°soben√≠ mantis (s implicitn√≠ 1)</h2>
                    <div class="calculation-step">
                        <strong>Mantisy s implicitn√≠ jedniƒçkou:</strong><br>
                        X<sub>s</sub> = ${mantissaResult.mantissa1Str} = ${mantissaResult.mantissa1.toFixed(8)}<br>
                        Y<sub>s</sub> = ${mantissaResult.mantissa2Str} = ${mantissaResult.mantissa2.toFixed(8)}<br><br>
                        
                        <strong>N√°soben√≠ mantis:</strong><br>
                        X<sub>s</sub> √ó Y<sub>s</sub> = ${mantissaResult.mantissa1.toFixed(8)} √ó ${mantissaResult.mantissa2.toFixed(8)} = ${mantissaResult.product.toFixed(8)}<br><br>
                        
                        <strong>V√Ωsledek v bin√°rn√≠m form√°tu:</strong><br>
                        ${mantissaResult.fullBinary}<sub>2</sub><br><br>
                        
                        <div class="step-highlight">
                            Souƒçin mantis: <strong>${mantissaResult.product.toFixed(8)}</strong>
                        </div>
                    </div>
                </div>`;
                
                // Krok 4: Normalizace
                const normalized = normalizeMultiplicationProduct(mantissaResult.product, exponentSum);
                html += `<div class="section">
                    <h2>Krok 4: Normalizace v√Ωsledku</h2>
                    <div class="calculation-step">
                        <strong>P≈Øvodn√≠ souƒçin:</strong> ${mantissaResult.product.toFixed(8)} = ${normalized.fullBinary}<sub>2</sub><br><br>
                        
                        <strong>Normalizace:</strong><br>`;
                
                if (normalized.shift > 0) {
                    html += `Posun doprava o ${normalized.shift} pozic ‚Üí exponent +${normalized.shift}<br>`;
                } else if (normalized.shift < 0) {
                    html += `Posun doleva o ${Math.abs(normalized.shift)} pozic ‚Üí exponent ${normalized.shift}<br>`;
                } else {
                    html += `≈Ω√°dn√Ω posun pot≈ôebn√Ω<br>`;
                }
                
                html += `Nov√Ω exponent: ${exponentSum} ${normalized.shift !== 0 ? `+ (${normalized.shift})` : ''} = ${normalized.newExponent}<br>
                        Biased exponent: ${normalized.newExponent} + 127 = ${normalized.biasedExponent}<br>
                        Normalizovan√° mantissa: ${normalized.mantissa}<br><br>
                        
                        <div class="step-highlight">
                            Fin√°ln√≠ exponent: <strong>${normalized.newExponent}</strong><br>
                            Fin√°ln√≠ mantissa: <strong>${normalized.mantissa}</strong>
                        </div>
                    </div>
                </div>`;
                
                // Krok 5: Sestaven√≠ v√Ωsledku
                const resultBinary = ieee754ToBinary(resultSign, normalized.exponentBin, normalized.mantissa);
                const actualResult = num1 * num2;
                const calculatedResult = binaryToFloat(resultBinary);
                
                html += `<div class="section">
                    <h2>Krok 5: Sestaven√≠ IEEE 754 v√Ωsledku</h2>
                    
                    <div class="formula-display">
                        X √ó Y = (X<sub>s</sub> √ó Y<sub>s</sub>) √ó 2<sup>X<sub>E</sub> + Y<sub>E</sub> + posun</sup>
                    </div>
                    
                    <div class="binary-display">
                        V√Ωsledek: <span class="sign">${resultSign}</span> | <span class="exponent">${normalized.exponentBin}</span> | <span class="mantissa">${normalized.mantissa}</span>
                    </div>
                    
                    <table class="table">
                        <tr><th>ƒå√°st</th><th>Bin√°rnƒõ</th><th>Hodnota</th><th>Popis</th></tr>
                        <tr>
                            <td><strong>Znam√©nko</strong></td>
                            <td class="sign">${resultSign}</td>
                            <td>${resultSign === '1' ? 'Z√°porn√© (-1)' : 'Kladn√© (+1)'}</td>
                            <td>1 bit</td>
                        </tr>
                        <tr>
                            <td><strong>Exponent</strong></td>
                            <td class="exponent">${normalized.exponentBin}</td>
                            <td>${normalized.biasedExponent} (${normalized.newExponent}+127)</td>
                            <td>8 bit≈Ø</td>
                        </tr>
                        <tr>
                            <td><strong>Mantissa</strong></td>
                            <td class="mantissa">${normalized.mantissa}</td>
                            <td>1.${normalized.mantissa}</td>
                            <td>23 bit≈Ø</td>
                        </tr>
                    </table>
                    
                    <div class="final-result">
                        <h3>üéØ V√Ωsledek IEEE 754 n√°soben√≠:</h3>
                        <div style="font-size: 24px; margin: 15px 0;">
                            ${num1} √ó ${num2} = ${actualResult}
                        </div>
                        <div>IEEE 754 v√Ωpoƒçet: ${calculatedResult.toFixed(8)}</div>
                        <div>Bin√°rn√≠ reprezentace: ${resultBinary}</div>
                        <div>Hexadecim√°lnƒõ: 0x${parseInt(resultBinary, 2).toString(16).toUpperCase().padStart(8, '0')}</div>
                        <div style="margin-top: 10px;">
                            P≈ôesnost: ${Math.abs(actualResult - calculatedResult) < 1e-6 ? '‚úÖ Velmi p≈ôesn√Ω' : '‚ö†Ô∏è Drobn√© zaokrouhlen√≠'}
                        </div>
                    </div>
                </div>`;
                
                document.getElementById('ieee-mult-results').innerHTML = html;
                
            } catch (error) {
                document.getElementById('ieee-mult-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
            }
        }
        // Initialize on load
        window.onload = function() {
            runQuineMcCluskey();
            calculateIEEE754Addition();
            calculateBinaryArithmetic();
            calculateIEEE754Multiplication();
        };
    </script>
</body>
</html>
