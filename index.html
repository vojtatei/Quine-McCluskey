<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktivní učení informatiky</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .navbar {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
        }
        
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            gap: 1rem;
        }
        
        .nav-item {
            position: relative;
        }
        
        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 25px;
            color: white;
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .nav-link.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .hamburger {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 0.5rem;
        }
        
        .hamburger span {
            width: 25px;
            height: 3px;
            background: white;
            margin: 3px 0;
            transition: 0.3s;
        }
        
        .main-content {
            margin-top: 80px;
            padding: 20px;
            min-height: calc(100vh - 80px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .topic-section {
            display: none;
        }
        
        .topic-section.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 2.5em;
        }
        
        .input-section {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        label {
            font-weight: bold;
            color: #fff;
        }
        
        input[type="text"], input[type="number"] {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
        }
        
        input[type="text"] {
            width: 300px;
        }
        
        input[type="number"] {
            width: 120px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .preset-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .main-content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .main-content-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .section h2 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        /* Responsive Navigation */
        @media (max-width: 768px) {
            .hamburger {
                display: flex;
            }
            
            .nav-menu {
                position: fixed;
                left: -100%;
                top: 70px;
                flex-direction: column;
                background: rgba(0, 0, 0, 0.95);
                width: 100%;
                text-align: center;
                transition: 0.3s;
                backdrop-filter: blur(10px);
                padding: 2rem 0;
            }
            
            .nav-menu.active {
                left: 0;
            }
            
            .nav-link {
                margin: 0.5rem 1rem;
            }
        }
        
        /* Společné styly pro obě sekce */
        .iteration-table, .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .iteration-table th, .iteration-table td,
        .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }
        
        .iteration-table th, .table th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .iteration-table tr:nth-child(even),
        .table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .combined-term {
            background: #e8f5e8 !important;
            font-weight: bold;
        }
        
        .binary-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
            letter-spacing: 2px;
        }
        
        .sign { color: #e74c3c; }
        .exponent { color: #f39c12; }
        .mantissa { color: #27ae60; }
        
        .final-result {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .step-explanation, .calculation-step {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .info-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .kmap-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .kmap {
            border-collapse: collapse;
            border: 2px solid #333;
            background: white;
        }
        
        .kmap td, .kmap th {
            width: 40px;
            height: 40px;
            border: 1px solid #666;
            text-align: center;
            vertical-align: middle;
            font-weight: bold;
        }
        
        .kmap th {
            background: #3498db;
            color: white;
        }
        
        .kmap .one {
            background: #e74c3c;
            color: white;
        }
        
        .kmap .zero {
            background: #ecf0f1;
            color: #7f8c8d;
        }
        
        .coverage-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }
        
        .coverage-table th,
        .coverage-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .coverage-table th {
            background: #2c3e50;
            color: white;
        }
        
        .coverage-table .covered {
            background: #2ecc71;
            color: white;
            font-weight: bold;
        }
        
        .welcome-section {
            text-align: center;
            padding: 3rem 0;
        }
        
        .welcome-section h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .welcome-section p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }
        
        .topic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }
        
        .topic-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        
        .topic-card:hover {
            transform: translateY(-5px);
        }
        
        .topic-card h3 {
            margin-bottom: 1rem;
            color: #fff;
        }
        
        .topic-card p {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">📚 CS Learning Platform</div>
            <ul class="nav-menu" id="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link active" onclick="showSection('welcome')">
                        🏠 Úvod
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('quine-mccluskey')">
                        🔧 Quine-McCluskey
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('ieee754')">
                        🔢 IEEE 754
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('binary-arithmetic')">
                        🧮 Binární aritmetika
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" onclick="showSection('coming-soon')">
                        ⭐ Další témata
                    </a>
                </li>
            </ul>
            <div class="hamburger" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main class="main-content">
        <div class="container">
            <!-- Úvodní sekce -->
            <section id="welcome" class="topic-section active">
                <div class="welcome-section">
                    <h1>🎓 Interaktivní učení informatiky</h1>
                    <p>Prozkoumej složité koncepty informatiky pomocí interaktivních nástrojů a vizualizací</p>
                    
                    <div class="topic-grid">
                        <div class="topic-card" onclick="showSection('quine-mccluskey')">
                            <h3>🔧 Quine-McCluskey metoda</h3>
                            <p>Minimalizace logických funkcí krok za krokem. Naučte se, jak algoritmus systematicky redukuje Boolean výrazy na nejjednodušší formu.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('ieee754')">
                            <h3>🔢 IEEE 754 Floating Point</h3>
                            <p>Pochopte, jak počítače ukládají a počítají s desetinnými čísly. Sledujte proces sčítání floating point čísel bit po bitu.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('binary-arithmetic')">
                            <h3>🧮 Binární aritmetika</h3>
                            <p>Naučte se sčítat, odčítat, násobit a dělit v binární soustavě. Pochopte, jak CPU provádí základní aritmetické operace.</p>
                        </div>
                        
                        <div class="topic-card" onclick="showSection('coming-soon')">
                            <h3>⭐ Připravujeme...</h3>
                            <p>Další témata jako algoritmy řazení, datové struktury, nebo síťové protokoly budou brzy dostupné!</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Quine-McCluskey sekce -->
            <section id="quine-mccluskey" class="topic-section">
                <h1>🔧 Quine-McCluskey metoda a Petrickova funkce</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="minterms">Mintermy (čárkou oddělené):</label>
                        <input type="text" id="minterms" value="2,4,6,8,9,10,12,13,15" placeholder="např. 2,4,6,8,9,10,12,13,15">
                        <button onclick="runQuineMcCluskey()">🚀 Spustit minimalizaci</button>
                    </div>
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadQMPreset('2,4,6,8,9,10,12,13,15')">Příklad z obrázku</button>
                        <button class="preset-btn" onclick="loadQMPreset('0,1,2,5,8,9,10')">Příklad 2</button>
                        <button class="preset-btn" onclick="loadQMPreset('4,5,6,8,9,10,13')">Příklad 3</button>
                        <button class="preset-btn" onclick="loadQMPreset('1,3,7,11,15')">Příklad 4</button>
                    </div>
                </div>
                
                <div class="main-content-grid">
                    <div class="section">
                        <h2>📊 Quine-McCluskey iterace</h2>
                        <div id="qm-iterations"></div>
                    </div>
                    
                    <div class="section">
                        <h2>🗺️ Karnaughova mapa</h2>
                        <div id="qm-kmap"></div>
                    </div>
                </div>
                
                <div class="section full-width">
                    <h2>🧮 Petrickova funkce a pokrytí</h2>
                    <div id="qm-petrick"></div>
                    <div id="qm-coverage"></div>
                    <div id="qm-final-result"></div>
                </div>
            </section>

            <!-- Binární aritmetika sekce -->
            <section id="binary-arithmetic" class="topic-section">
                <h1>🧮 Binární aritmetika</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="bin-num1">Číslo A (binárně nebo desetinně):</label>
                        <input type="text" id="bin-num1" value="01011010" placeholder="např. 01011010 nebo 90">
                        
                        <label for="bin-operation">Operace:</label>
                        <select id="bin-operation" style="padding: 10px 15px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.9); color: #333; font-size: 16px;">
                            <option value="add">Sčítání (+)</option>
                            <option value="subtract">Odčítání (-)</option>
                            <option value="multiply">Násobení (×)</option>
                            <option value="divide">Dělení (÷)</option>
                        </select>
                        
                        <label for="bin-num2">Číslo B (binárně nebo desetinně):</label>
                        <input type="text" id="bin-num2" value="00101100" placeholder="např. 00101100 nebo 44">
                        
                        <button onclick="calculateBinaryArithmetic()">🚀 Spočítat</button>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadBinaryPreset('01011010', '00101100', 'subtract')">Odčítání: 90 - 44</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('00110111', '00000101', 'divide')">Dělení: 55 ÷ 5</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('00000100', '00000111', 'multiply')">Násobení: 4 × 7</button>
                        <button class="preset-btn" onclick="loadBinaryPreset('01000100', '01011010', 'add')">Sčítání: 68 + 90</button>
                    </div>
                </div>
                
                <div id="binary-results"></div>
            </section>

            <!-- IEEE 754 sekce -->
            <section id="ieee754" class="topic-section">
                <h1>🔢 IEEE 754 Sčítání čísel (32-bit Float)</h1>
                
                <div class="input-section">
                    <div class="controls">
                        <label for="ieee-num1">Číslo A:</label>
                        <input type="number" id="ieee-num1" value="3.75" step="any">
                        
                        <label for="ieee-num2">Číslo B:</label>
                        <input type="number" id="ieee-num2" value="1.25" step="any">
                        
                        <button onclick="calculateIEEE754Addition()">🧮 Spočítat sčítání</button>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="loadIEEEExample(3.75, 1.25)">Příklad 1: 3.75 + 1.25</button>
                        <button class="preset-btn" onclick="loadIEEEExample(5.5, -2.25)">Příklad 2: 5.5 + (-2.25)</button>
                        <button class="preset-btn" onclick="loadIEEEExample(0.125, 0.375)">Příklad 3: 0.125 + 0.375</button>
                        <button class="preset-btn" onclick="loadIEEEExample(7.0, 0.5)">Příklad 4: 7.0 + 0.5</button>
                    </div>
                </div>
                
                <div id="ieee-results"></div>
            </section>

            <!-- Coming Soon sekce -->
            <section id="coming-soon" class="topic-section">
                <div class="welcome-section">
                    <h1>⭐ Další témata v přípravě</h1>
                    <p>Připravujeme další interaktivní nástroje pro učení informatiky</p>
                    
                    <div class="topic-grid">
                        <div class="topic-card">
                            <h3>🗂️ Datové struktury</h3>
                            <p>Vizualizace stromů, hashmap, linked listů a dalších datových struktur s interaktivními operacemi.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>🔀 Algoritmy řazení</h3>
                            <p>Sledujte algoritmy jako Quick Sort, Merge Sort, Bubble Sort krok za krokem s animacemi.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>🌐 Síťové protokoly</h3>
                            <p>Pochopte TCP/IP, HTTP, DNS a další protokoly pomocí interaktivních diagramů.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>🔐 Kryptografie</h3>
                            <p>Prozkoumejte šifrovací algoritmy, hash funkce a digitální podpisy.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>🤖 Automatové teorie</h3>
                            <p>Konečné automaty, regulární výrazy a formální jazyky s interaktivními simulátory.</p>
                        </div>
                        
                        <div class="topic-card">
                            <h3>💾 Operační systémy</h3>
                            <p>Plánování procesů, správa paměti a filesystémy s praktickými ukázkami.</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        // Navigation functionality
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.topic-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Add active class to corresponding nav link
            event.target.classList.add('active');
            
            // Close mobile menu if open
            document.getElementById('nav-menu').classList.remove('active');
        }

        function toggleMenu() {
            document.getElementById('nav-menu').classList.toggle('active');
        }

        // Quine-McCluskey functionality
        class QuineMcCluskey {
            constructor() {
                this.variables = 4;
                this.varNames = ['W', 'X', 'Y', 'Z'];
            }

            toBinary(num, bits) {
                return num.toString(2).padStart(bits, '0');
            }

            countOnes(binary) {
                return binary.split('1').length - 1;
            }

            canCombine(term1, term2) {
                let differences = 0;
                for (let i = 0; i < term1.length; i++) {
                    if (term1[i] !== term2[i]) {
                        differences++;
                        if (differences > 1) return false;
                    }
                }
                return differences === 1;
            }

            combine(term1, term2) {
                let result = '';
                for (let i = 0; i < term1.length; i++) {
                    if (term1[i] !== term2[i]) {
                        result += '-';
                    } else {
                        result += term1[i];
                    }
                }
                return result;
            }

            quineMcCluskey(minterms) {
                if (!minterms || minterms.length === 0) return [];

                let iterations = [];
                let currentTerms = new Map();
                
                for (let minterm of minterms) {
                    let binary = this.toBinary(minterm, this.variables);
                    currentTerms.set(binary, [minterm]);
                }

                let iterationNum = 1;
                
                while (true) {
                    let nextTerms = new Map();
                    let used = new Set();
                    let groups = new Map();
                    
                    for (let [term, origins] of currentTerms) {
                        let ones = this.countOnes(term);
                        if (!groups.has(ones)) {
                            groups.set(ones, []);
                        }
                        groups.get(ones).push({term, origins});
                    }
                    
                    let iterationData = {
                        iteration: iterationNum,
                        groups: [],
                        combinations: []
                    };
                    
                    for (let [ones, terms] of groups) {
                        iterationData.groups.push({
                            ones: ones,
                            terms: terms.map(t => ({
                                binary: t.term,
                                origins: t.origins
                            }))
                        });
                    }
                    
                    let sortedGroups = Array.from(groups.keys()).sort((a, b) => a - b);
                    for (let i = 0; i < sortedGroups.length - 1; i++) {
                        let group1 = groups.get(sortedGroups[i]);
                        let group2 = groups.get(sortedGroups[i + 1]);
                        
                        for (let term1 of group1) {
                            for (let term2 of group2) {
                                if (this.canCombine(term1.term, term2.term)) {
                                    let combined = this.combine(term1.term, term2.term);
                                    let newOrigins = [...new Set([...term1.origins, ...term2.origins])].sort((a, b) => a - b);
                                    
                                    nextTerms.set(combined, newOrigins);
                                    used.add(term1.term);
                                    used.add(term2.term);
                                    
                                    iterationData.combinations.push({
                                        term1: term1.term,
                                        term2: term2.term,
                                        result: combined,
                                        origins: newOrigins
                                    });
                                }
                            }
                        }
                    }
                    
                    iterations.push(iterationData);
                    
                    if (nextTerms.size === 0) break;
                    
                    for (let [term, origins] of currentTerms) {
                        if (!used.has(term)) {
                            nextTerms.set(term, origins);
                        }
                    }
                    
                    currentTerms = nextTerms;
                    iterationNum++;
                }
                
                let primeImplicants = [];
                for (let [term, origins] of currentTerms) {
                    primeImplicants.push({term, origins});
                }
                
                return {iterations, primeImplicants};
            }

            generateKMap(minterms) {
                let kmap = Array(4).fill().map(() => Array(4).fill(0));
                let grayCode = ['00', '01', '11', '10'];
                
                for (let minterm of minterms) {
                    let binary = this.toBinary(minterm, 4);
                    let wx = binary.substring(0, 2);
                    let yz = binary.substring(2, 4);
                    
                    let row = grayCode.indexOf(wx);
                    let col = grayCode.indexOf(yz);
                    
                    kmap[row][col] = 1;
                }
                
                return kmap;
            }

            petrickFunction(primeImplicants, minterms) {
                let coverageTable = [];
                
                for (let minterm of minterms) {
                    let coverage = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        let pi = primeImplicants[i];
                        coverage.push(pi.origins.includes(minterm) ? 1 : 0);
                    }
                    coverageTable.push({minterm, coverage});
                }
                
                let essentialPIs = new Set();
                let coveredMinterms = new Set();
                
                for (let row of coverageTable) {
                    let coveringPIs = [];
                    for (let i = 0; i < row.coverage.length; i++) {
                        if (row.coverage[i] === 1) {
                            coveringPIs.push(i);
                        }
                    }
                    if (coveringPIs.length === 1) {
                        essentialPIs.add(coveringPIs[0]);
                    }
                }
                
                for (let piIndex of essentialPIs) {
                    for (let minterm of primeImplicants[piIndex].origins) {
                        coveredMinterms.add(minterm);
                    }
                }
                
                let uncoveredMinterms = minterms.filter(m => !coveredMinterms.has(m));
                
                if (uncoveredMinterms.length === 0) {
                    return {
                        coverageTable, 
                        solution: Array.from(essentialPIs),
                        essentialPIs: Array.from(essentialPIs),
                        petrickExpression: "Všechny mintermy pokryté esenciálními PI"
                    };
                }
                
                let bestSolution = this.findOptimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs);
                
                let petrickTerms = [];
                for (let minterm of uncoveredMinterms) {
                    let termPIs = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (primeImplicants[i].origins.includes(minterm) && !essentialPIs.has(i)) {
                            termPIs.push(`P${i}`);
                        }
                    }
                    if (termPIs.length > 0) {
                        petrickTerms.push(`(${termPIs.join(' + ')})`);
                    }
                }
                
                let petrickExpression = petrickTerms.length > 0 ? 
                    petrickTerms.join(' · ') : 
                    "Žádné další mintermy k pokrytí";
                
                return {
                    coverageTable, 
                    solution: bestSolution,
                    essentialPIs: Array.from(essentialPIs),
                    petrickExpression: petrickExpression
                };
            }

            findOptimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs) {
                if (uncoveredMinterms.length === 0) {
                    return Array.from(essentialPIs);
                }
                
                if (uncoveredMinterms.length <= 6) {
                    let candidatePIs = [];
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (!essentialPIs.has(i)) {
                            for (let minterm of uncoveredMinterms) {
                                if (primeImplicants[i].origins.includes(minterm)) {
                                    candidatePIs.push(i);
                                    break;
                                }
                            }
                        }
                    }
                    
                    let bestSolution = null;
                    let bestCost = Infinity;
                    
                    for (let mask = 1; mask < (1 << candidatePIs.length); mask++) {
                        let currentSolution = Array.from(essentialPIs);
                        let covered = new Set();
                        
                        for (let piIndex of essentialPIs) {
                            for (let minterm of primeImplicants[piIndex].origins) {
                                covered.add(minterm);
                            }
                        }
                        
                        for (let i = 0; i < candidatePIs.length; i++) {
                            if (mask & (1 << i)) {
                                let piIndex = candidatePIs[i];
                                currentSolution.push(piIndex);
                                for (let minterm of primeImplicants[piIndex].origins) {
                                    covered.add(minterm);
                                }
                            }
                        }
                        
                        let allCovered = true;
                        for (let minterm of uncoveredMinterms) {
                            if (!covered.has(minterm)) {
                                allCovered = false;
                                break;
                            }
                        }
                        
                        if (allCovered) {
                            let cost = 0;
                            for (let piIndex of currentSolution) {
                                let term = primeImplicants[piIndex].term;
                                cost += term.length - (term.match(/-/g) || []).length;
                            }
                            
                            if (cost < bestCost) {
                                bestCost = cost;
                                bestSolution = currentSolution;
                            }
                        }
                    }
                    
                    if (bestSolution) {
                        return bestSolution;
                    }
                }
                
                return this.findMinimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs);
            }

            findMinimalCoverage(primeImplicants, uncoveredMinterms, essentialPIs) {
                let solution = Array.from(essentialPIs);
                let remaining = new Set(uncoveredMinterms);
                
                while (remaining.size > 0) {
                    let bestPI = -1;
                    let bestCoverage = 0;
                    
                    for (let i = 0; i < primeImplicants.length; i++) {
                        if (solution.includes(i)) continue;
                        
                        let coverage = 0;
                        for (let minterm of primeImplicants[i].origins) {
                            if (remaining.has(minterm)) {
                                coverage++;
                            }
                        }
                        
                        if (coverage > bestCoverage) {
                            bestCoverage = coverage;
                            bestPI = i;
                        }
                    }
                    
                    if (bestPI === -1) break;
                    
                    solution.push(bestPI);
                    for (let minterm of primeImplicants[bestPI].origins) {
                        remaining.delete(minterm);
                    }
                }
                
                return solution;
            }

            termToAlgebraic(term) {
                let result = '';
                for (let i = 0; i < term.length; i++) {
                    if (term[i] !== '-') {
                        if (result !== '') result += '';
                        if (term[i] === '0') {
                            result += this.varNames[i] + "'";
                        } else {
                            result += this.varNames[i];
                        }
                    }
                }
                return result || '1';
            }
        }

        const qm = new QuineMcCluskey();

        function loadQMPreset(minterms) {
            document.getElementById('minterms').value = minterms;
            runQuineMcCluskey();
        }

        function runQuineMcCluskey() {
            try {
                let input = document.getElementById('minterms').value;
                let minterms = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
                
                if (minterms.length === 0) {
                    throw new Error('Zadejte platné mintermy');
                }
                
                let maxMinterm = Math.max(...minterms);
                if (maxMinterm >= 16) {
                    throw new Error('Mintermy musí být v rozsahu 0-15 pro 4 proměnné');
                }
                
                let result = qm.quineMcCluskey(minterms);
                let petrickResult = qm.petrickFunction(result.primeImplicants, minterms);
                
                displayQMIterations(result.iterations);
                displayQMKMap(qm.generateKMap(minterms), minterms);
                displayQMPetrick(result.primeImplicants, petrickResult, minterms);
                
            } catch (error) {
                document.getElementById('qm-iterations').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
                document.getElementById('qm-kmap').innerHTML = '';
                document.getElementById('qm-petrick').innerHTML = '';
                document.getElementById('qm-coverage').innerHTML = '';
                document.getElementById('qm-final-result').innerHTML = '';
            }
        }

        function displayQMIterations(iterations) {
            let html = '';
            
            for (let iter of iterations) {
                html += `<h3>Iterace ${iter.iteration}</h3>`;
                
                if (iter.groups.length > 0) {
                    html += '<table class="iteration-table">';
                    html += '<tr><th>Počet jedniček</th><th>Binární</th><th>Mintermy</th></tr>';
                    
                    for (let group of iter.groups) {
                        for (let term of group.terms) {
                            html += `<tr>`;
                            html += `<td>${group.ones}</td>`;
                            html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${term.binary}</td>`;
                            html += `<td>${term.origins.join(', ')}</td>`;
                            html += `</tr>`;
                        }
                    }
                    html += '</table>';
                }
                
                if (iter.combinations.length > 0) {
                    html += '<div class="step-explanation">Kombinace:</div>';
                    html += '<table class="iteration-table">';
                    html += '<tr><th>Term 1</th><th>Term 2</th><th>Kombinovaný</th><th>Mintermy</th></tr>';
                    
                    for (let combo of iter.combinations) {
                        html += `<tr class="combined-term">`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.term1}</td>`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.term2}</td>`;
                        html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${combo.result}</td>`;
                        html += `<td>${combo.origins.join(', ')}</td>`;
                        html += `</tr>`;
                    }
                    html += '</table>';
                } else {
                    html += '<div class="step-explanation">Žádné další kombinace možné - konec</div>';
                }
            }
            
            document.getElementById('qm-iterations').innerHTML = html;
        }

        function displayQMKMap(kmap, minterms) {
            let html = '<div class="kmap-container">';
            html += '<table class="kmap">';
            
            html += '<tr><th>WX\\YZ</th><th>00</th><th>01</th><th>11</th><th>10</th></tr>';
            
            let grayRows = ['00', '01', '11', '10'];
            
            for (let i = 0; i < 4; i++) {
                html += `<tr><th>${grayRows[i]}</th>`;
                for (let j = 0; j < 4; j++) {
                    let value = kmap[i][j];
                    let className = value === 1 ? 'one' : 'zero';
                    html += `<td class="${className}">${value}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</table>';
            html += '</div>';
            
            html += '<div class="step-explanation">Červené buňky = mintermy, šedé = nepoužité</div>';
            
            document.getElementById('qm-kmap').innerHTML = html;
        }

        function displayQMPetrick(primeImplicants, petrickResult, minterms) {
            let html = '<h3>Prime implicanty:</h3>';
            html += '<table class="iteration-table">';
            html += '<tr><th>Index</th><th>Binární</th><th>Algebraicky</th><th>Pokrývá mintermy</th><th>Typ</th></tr>';
            
            for (let i = 0; i < primeImplicants.length; i++) {
                let pi = primeImplicants[i];
                let isEssential = petrickResult.essentialPIs.includes(i);
                let isUsed = petrickResult.solution.includes(i);
                let type = isEssential ? 'Esenciální' : (isUsed ? 'Použitý' : 'Nepoužitý');
                let rowClass = isEssential ? 'style="background: #e8f5e8 !important;"' : 
                              (isUsed ? 'style="background: #fff3cd !important;"' : '');
                
                html += `<tr ${rowClass}>`;
                html += `<td>P${i}</td>`;
                html += `<td class="binary-display" style="font-size: 14px; padding: 5px;">${pi.term}</td>`;
                html += `<td>${qm.termToAlgebraic(pi.term)}</td>`;
                html += `<td>${pi.origins.join(', ')}</td>`;
                html += `<td><strong>${type}</strong></td>`;
                html += `</tr>`;
            }
            html += '</table>';
            
            if (petrickResult.petrickExpression && petrickResult.petrickExpression !== "Všechny mintermy pokryté esenciálními PI") {
                html += '<div class="step-explanation">';
                html += '<h4>Petrickova funkce pro nepokryté mintermy:</h4>';
                html += `<div style="font-family: monospace; font-size: 16px; padding: 10px; background: #f0f0f0; border-radius: 5px; color: #333;">`;
                html += `P = ${petrickResult.petrickExpression}</div>`;
                html += '</div>';
            }
            
            document.getElementById('qm-petrick').innerHTML = html;
            
            html = '<h3>Tabulka pokrytí:</h3>';
            html += '<table class="coverage-table">';
            html += '<tr><th>Minterm</th>';
            for (let i = 0; i < primeImplicants.length; i++) {
                let isUsed = petrickResult.solution.includes(i);
                let headerClass = isUsed ? 'style="background: #27ae60 !important;"' : '';
                html += `<th ${headerClass}>P${i}</th>`;
            }
            html += '</tr>';
            
            for (let row of petrickResult.coverageTable) {
                html += `<tr><td><strong>${row.minterm}</strong></td>`;
                for (let i = 0; i < row.coverage.length; i++) {
                    let className = row.coverage[i] === 1 ? 'covered' : '';
                    html += `<td class="${className}">${row.coverage[i] === 1 ? '✓' : ''}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            document.getElementById('qm-coverage').innerHTML = html;
            
            let selectedPIs = petrickResult.solution.map(i => qm.termToAlgebraic(primeImplicants[i].term));
            let finalExpression = selectedPIs.join(' + ');
            
            html = `<div class="final-result">`;
            html += `<h3>🎯 Minimální výraz:</h3>`;
            html += `<div style="font-size: 24px; margin: 15px 0;">F = ${finalExpression}</div>`;
            html += `<div>Použité prime implicanty: ${petrickResult.solution.map(i => `P${i}`).join(', ')}</div>`;
            html += `<div style="margin-top: 10px;">Esenciální PI: ${petrickResult.essentialPIs.map(i => `P${i}`).join(', ') || 'žádné'}</div>`;
            html += `<div>Celkem literálů: ${selectedPIs.join('').replace(/[^A-Z']/g, '').length}</div>`;
            html += `</div>`;
            
            document.getElementById('qm-final-result').innerHTML = html;
        }

        // IEEE 754 functionality
        function loadIEEEExample(a, b) {
            document.getElementById('ieee-num1').value = a;
            document.getElementById('ieee-num2').value = b;
            calculateIEEE754Addition();
        }

        function floatToIEEE754(num) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setFloat32(0, num, false);
            const bits = view.getUint32(0, false);
            
            const binary = bits.toString(2).padStart(32, '0');
            const sign = binary[0];
            const exponent = binary.slice(1, 9);
            const mantissa = binary.slice(9);
            
            return {
                binary: binary,
                sign: sign,
                exponent: exponent,
                mantissa: mantissa,
                exponentValue: parseInt(exponent, 2),
                biasedExponent: parseInt(exponent, 2) - 127,
                mantissaValue: 1 + parseInt(mantissa, 2) / Math.pow(2, 23)
            };
        }

        function ieee754ToBinary(sign, exponent, mantissa) {
            return sign + exponent + mantissa;
        }

        function binaryToFloat(binary) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setUint32(0, parseInt(binary, 2), false);
            return view.getFloat32(0, false);
        }

        function addMantissas(m1, m2, expDiff) {
            const mantissa1 = Math.round((1 + parseInt(m1, 2) / Math.pow(2, 23)) * Math.pow(2, 23));
            let mantissa2 = Math.round((1 + parseInt(m2, 2) / Math.pow(2, 23)) * Math.pow(2, 23));
            
            mantissa2 = Math.round(mantissa2 / Math.pow(2, expDiff));
            
            const sum = mantissa1 + mantissa2;
            
            return {
                mantissa1: mantissa1,
                mantissa2: mantissa2,
                sum: sum,
                mantissa1Bin: (mantissa1).toString(2),
                mantissa2Bin: (mantissa2).toString(2),
                sumBin: sum.toString(2)
            };
        }

        function normalizeResult(sum, exponent) {
            let sumBin = sum.toString(2);
            let newExponent = exponent;
            
            if (sumBin.length > 24) {
                const shift = sumBin.length - 24;
                newExponent += shift;
                sumBin = sumBin.slice(0, 24);
            }
            
            let mantissa = sumBin.slice(1, 24).padEnd(23, '0');
            
            return {
                mantissa: mantissa,
                exponent: newExponent,
                exponentBin: (newExponent + 127).toString(2).padStart(8, '0')
            };
        }

        function calculateIEEE754Addition() {
            try {
                const num1 = parseFloat(document.getElementById('ieee-num1').value);
                const num2 = parseFloat(document.getElementById('ieee-num2').value);
                
                if (isNaN(num1) || isNaN(num2)) {
                    throw new Error('Zadejte platná čísla');
                }
                
                const ieee1 = floatToIEEE754(num1);
                const ieee2 = floatToIEEE754(num2);
                
                let html = '';
                
                html += `<div class="section">
                    <h2>Krok 1: IEEE 754 reprezentace čísel</h2>
                    <div class="info-box">
                        <strong>Struktura IEEE 754 (32-bit):</strong><br>
                        <span class="sign">S</span> = znaménko (1 bit), 
                        <span class="exponent">EEEEEEEE</span> = exponent + 127 (8 bitů), 
                        <span class="mantissa">MMMMMMMMMMMMMMMMMMMMMMM</span> = mantisa (23 bitů)
                    </div>
                    
                    <table class="table">
                        <tr><th>Číslo</th><th>Desetinně</th><th>IEEE 754 Binary</th><th>Rozklad</th></tr>
                        <tr>
                            <td><strong>A</strong></td>
                            <td>${num1}</td>
                            <td class="binary-display">
                                <span class="sign">${ieee1.sign}</span>
                                <span class="exponent">${ieee1.exponent}</span>
                                <span class="mantissa">${ieee1.mantissa}</span>
                            </td>
                            <td>Exp: ${ieee1.exponentValue} (${ieee1.biasedExponent}+127)<br>
                                Mantisa: 1.${ieee1.mantissa} ≈ ${ieee1.mantissaValue.toFixed(6)}</td>
                        </tr>
                        <tr>
                            <td><strong>B</strong></td>
                            <td>${num2}</td>
                            <td class="binary-display">
                                <span class="sign">${ieee2.sign}</span>
                                <span class="exponent">${ieee2.exponent}</span>
                                <span class="mantissa">${ieee2.mantissa}</span>
                            </td>
                            <td>Exp: ${ieee2.exponentValue} (${ieee2.biasedExponent}+127)<br>
                                Mantisa: 1.${ieee2.mantissa} ≈ ${ieee2.mantissaValue.toFixed(6)}</td>
                        </tr>
                    </table>
                </div>`;
                
                const expDiff = Math.abs(ieee1.biasedExponent - ieee2.biasedExponent);
                const largerExp = Math.max(ieee1.biasedExponent, ieee2.biasedExponent);
                const isNum1Larger = ieee1.biasedExponent >= ieee2.biasedExponent;
                
                html += `<div class="section">
                    <h2>Krok 2: Srovnání exponentů</h2>
                    <div class="calculation-step">
                        <strong>Exponenty:</strong><br>
                        A: ${ieee1.biasedExponent} (${ieee1.exponent}₂)<br>
                        B: ${ieee2.biasedExponent} (${ieee2.exponent}₂)<br><br>
                        
                        <strong>Rozdíl exponentů:</strong> |${ieee1.biasedExponent} - ${ieee2.biasedExponent}| = ${expDiff}<br>
                        <strong>Větší exponent:</strong> ${largerExp}<br>
                        <strong>Menší mantisu je třeba posunout o ${expDiff} pozic doprava</strong>
                    </div>
                </div>`;
                
                let m1 = ieee1.mantissa;
                let m2 = ieee2.mantissa;
                let sign1 = ieee1.sign;
                let sign2 = ieee2.sign;
                
                if (!isNum1Larger) {
                    [m1, m2] = [m2, m1];
                    [sign1, sign2] = [sign2, sign1];
                }
                
                const mantissaCalc = addMantissas(m1, m2, expDiff);
                
                html += `<div class="section">
                    <h2>Krok 3: Posun mantisy a převod na celá čísla</h2>
                    <div class="calculation-step">
                        <strong>Normalizované mantisy (s implicitní 1):</strong><br>
                        Větší číslo: 1.${m1} → ${mantissaCalc.mantissa1} (celé číslo)<br>
                        Menší číslo: 1.${m2} → ${mantissaCalc.mantissa2} (posunuté o ${expDiff})<br><br>
                        
                        <strong>Binárně:</strong><br>
                        ${mantissaCalc.mantissa1Bin}₂<br>
                        ${mantissaCalc.mantissa2Bin}₂<br>
                        ────────────────────<br>
                        ${mantissaCalc.sumBin}₂ = ${mantissaCalc.sum}₁₀
                    </div>
                </div>`;
                
                const normalized = normalizeResult(mantissaCalc.sum, largerExp);
                
                html += `<div class="section">
                    <h2>Krok 4: Normalizace výsledku</h2>
                    <div class="calculation-step">
                        <strong>Suma mantis:</strong> ${mantissaCalc.sum} = ${mantissaCalc.sumBin}₂<br><br>
                        
                        <strong>Normalizace:</strong><br>
                        Exponent: ${normalized.exponent} → ${normalized.exponent + 127} → ${normalized.exponentBin}₂<br>
                        Mantisa: ${normalized.mantissa} (bez implicitní 1)
                    </div>
                </div>`;
                
                const resultSign = (num1 + num2) >= 0 ? '0' : '1';
                const resultBinary = ieee754ToBinary(resultSign, normalized.exponentBin, normalized.mantissa);
                const actualResult = num1 + num2;
                const calculatedResult = binaryToFloat(resultBinary);
                
                html += `<div class="section">
                    <h2>Krok 5: Finální výsledek</h2>
                    <div class="binary-display">
                        <span class="sign">${resultSign}</span>
                        <span class="exponent">${normalized.exponentBin}</span>
                        <span class="mantissa">${normalized.mantissa}</span>
                    </div>
                    
                    <div class="final-result">
                        <h3>🎯 Výsledek sčítání:</h3>
                        <div style="font-size: 24px; margin: 15px 0;">${num1} + ${num2} = ${actualResult}</div>
                        <div>IEEE 754 výpočet: ${calculatedResult.toFixed(6)}</div>
                        <div>Přesnost: ${Math.abs(actualResult - calculatedResult) < 0.000001 ? '✅ Přesný' : '⚠️ Zaokrouhlení'}</div>
                    </div>
                </div>`;
                
                document.getElementById('ieee-results').innerHTML = html;
                
            } catch (error) {
                document.getElementById('ieee-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
            }
        }

        // Binary arithmetic functionality
        function loadBinaryPreset(num1, num2, operation) {
            document.getElementById('bin-num1').value = num1;
            document.getElementById('bin-num2').value = num2;
            document.getElementById('bin-operation').value = operation;
            calculateBinaryArithmetic();
        }

        function parseBinaryInput(input) {
            // Pokud obsahuje jen 0 a 1, je to binární
            if (/^[01]+$/.test(input)) {
                return {
                    binary: input.padStart(8, '0'),
                    decimal: parseInt(input, 2)
                };
            } else {
                // Jinak je to desetinné číslo
                let decimal = parseInt(input);
                return {
                    binary: decimal.toString(2).padStart(8, '0'),
                    decimal: decimal
                };
            }
        }

        function binaryAddition(a, b) {
            let result = '';
            let carry = 0;
            let steps = [];
            
            // Ujisti se, že mají stejnou délku
            let maxLen = Math.max(a.length, b.length);
            a = a.padStart(maxLen, '0');
            b = b.padStart(maxLen, '0');
            
            for (let i = maxLen - 1; i >= 0; i--) {
                let bitA = parseInt(a[i]);
                let bitB = parseInt(b[i]);
                let sum = bitA + bitB + carry;
                
                steps.push({
                    position: maxLen - 1 - i,
                    bitA: bitA,
                    bitB: bitB,
                    carry: carry,
                    sum: sum,
                    result: sum % 2,
                    newCarry: Math.floor(sum / 2)
                });
                
                result = (sum % 2) + result;
                carry = Math.floor(sum / 2);
            }
            
            if (carry) {
                result = carry + result;
            }
            
            return { result, steps };
        }

        function binarySubtraction(a, b) {
            let steps = [];
            let result = '';
            let borrow = 0;
            
            let maxLen = Math.max(a.length, b.length);
            a = a.padStart(maxLen, '0');
            b = b.padStart(maxLen, '0');
            
            // Kontrola, zda a >= b
            if (parseInt(a, 2) < parseInt(b, 2)) {
                return {
                    result: 'ZÁPORNÝ VÝSLEDEK',
                    steps: [],
                    note: 'Pro zjednodušení ukazujeme jen kladné výsledky. V CPU by se použil doplňkový kód.'
                };
            }
            
            for (let i = maxLen - 1; i >= 0; i--) {
                let bitA = parseInt(a[i]) - borrow;
                let bitB = parseInt(b[i]);
                
                if (bitA < bitB) {
                    bitA += 2;
                    borrow = 1;
                } else {
                    borrow = 0;
                }
                
                let diff = bitA - bitB;
                
                steps.push({
                    position: maxLen - 1 - i,
                    originalA: parseInt(a[i]),
                    bitA: bitA,
                    bitB: bitB,
                    borrow: borrow,
                    result: diff
                });
                
                result = diff + result;
            }
            
            // Odstraň vedoucí nuly
            result = result.replace(/^0+/, '') || '0';
            
            return { result, steps };
        }

        function binaryMultiplication(a, b) {
            let steps = [];
            let partialProducts = [];
            
            let decimalA = parseInt(a, 2);
            let decimalB = parseInt(b, 2);
            
            for (let i = b.length - 1; i >= 0; i--) {
                if (b[i] === '1') {
                    let shift = b.length - 1 - i;
                    let product = a + '0'.repeat(shift);
                    partialProducts.push({
                        multiplier: b[i],
                        shift: shift,
                        product: product,
                        position: i
                    });
                }
            }
            
            // Sečti všechny částečné součiny
            let finalResult = '0';
            for (let product of partialProducts) {
                let addition = binaryAddition(finalResult, product.product);
                finalResult = addition.result;
            }
            
            return {
                result: finalResult,
                partialProducts: partialProducts,
                decimalResult: decimalA * decimalB
            };
        }

        function binaryDivision(dividend, divisor) {
            let quotient = '';
            let remainder = '';
            let steps = [];
            
            let decimalDividend = parseInt(dividend, 2);
            let decimalDivisor = parseInt(divisor, 2);
            
            if (decimalDivisor === 0) {
                return { error: 'Dělení nulou!' };
            }
            
            let currentDividend = '';
            
            for (let i = 0; i < dividend.length; i++) {
                currentDividend += dividend[i];
                let currentDecimal = parseInt(currentDividend, 2) || 0;
                
                if (currentDecimal >= decimalDivisor) {
                    quotient += '1';
                    let subtraction = (currentDecimal - decimalDivisor).toString(2);
                    remainder = subtraction;
                    currentDividend = remainder;
                    
                    steps.push({
                        step: i + 1,
                        currentDividend: currentDividend,
                        comparison: `${currentDecimal} >= ${decimalDivisor}`,
                        quotientBit: '1',
                        newRemainder: remainder
                    });
                } else {
                    quotient += '0';
                    steps.push({
                        step: i + 1,
                        currentDividend: currentDividend,
                        comparison: `${currentDecimal} < ${decimalDivisor}`,
                        quotientBit: '0',
                        newRemainder: currentDividend
                    });
                }
            }
            
            return {
                quotient: quotient.replace(/^0+/, '') || '0',
                remainder: remainder || '0',
                steps: steps,
                decimalQuotient: Math.floor(decimalDividend / decimalDivisor),
                decimalRemainder: decimalDividend % decimalDivisor
            };
        }

        function calculateBinaryArithmetic() {
            try {
                let input1 = document.getElementById('bin-num1').value.trim();
                let input2 = document.getElementById('bin-num2').value.trim();
                let operation = document.getElementById('bin-operation').value;
                
                if (!input1 || !input2) {
                    throw new Error('Zadejte obě čísla');
                }
                
                let num1 = parseBinaryInput(input1);
                let num2 = parseBinaryInput(input2);
                
                let html = '';
                
                // Zobrazení vstupních čísel
                html += `<div class="section">
                    <h2>Vstupní čísla</h2>
                    <table class="table">
                        <tr><th>Číslo</th><th>Binárně</th><th>Desetinně</th></tr>
                        <tr>
                            <td><strong>A</strong></td>
                            <td class="binary-display" style="font-size: 16px;">${num1.binary}</td>
                            <td>${num1.decimal}</td>
                        </tr>
                        <tr>
                            <td><strong>B</strong></td>
                            <td class="binary-display" style="font-size: 16px;">${num2.binary}</td>
                            <td>${num2.decimal}</td>
                        </tr>
                    </table>
                </div>`;
                
                // Provedení operace
                let result;
                switch (operation) {
                    case 'add':
                        result = binaryAddition(num1.binary, num2.binary);
                        html += displayAdditionSteps(num1, num2, result);
                        break;
                    case 'subtract':
                        result = binarySubtraction(num1.binary, num2.binary);
                        html += displaySubtractionSteps(num1, num2, result);
                        break;
                    case 'multiply':
                        result = binaryMultiplication(num1.binary, num2.binary);
                        html += displayMultiplicationSteps(num1, num2, result);
                        break;
                    case 'divide':
                        result = binaryDivision(num1.binary, num2.binary);
                        html += displayDivisionSteps(num1, num2, result);
                        break;
                    case 'non-restoring':
                        result = nonRestoringDivision(num1.binary, num2.binary);
                        html += displayNonRestoringSteps(num1, num2, result);
                        break;
                }
                
                document.getElementById('binary-results').innerHTML = html;
                
            } catch (error) {
                document.getElementById('binary-results').innerHTML = `<div class="error">Chyba: ${error.message}</div>`;
            }
        }

        function displayAdditionSteps(num1, num2, result) {
            let html = `<div class="section">
                <h2>🧮 Sčítání krok za krokem</h2>
                <div class="info-box">
                    <strong>Pravidla binárního sčítání:</strong><br>
                    0 + 0 = 0, &nbsp; 0 + 1 = 1, &nbsp; 1 + 0 = 1, &nbsp; 1 + 1 = 10 (přenos)
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;${num1.binary}<br>
                        + ${num2.binary}<br>
                        ─────────<br>
                        ${result.result.padStart(Math.max(num1.binary.length, num2.binary.length) + 1, ' ')}
                    </div>
                </div>
                
                <h3>Postupné kroky:</h3>
                <table class="table">
                    <tr><th>Pozice</th><th>Bit A</th><th>Bit B</th><th>Přenos</th><th>Součet</th><th>Výsledek</th><th>Nový přenos</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.position}</td>
                    <td>${step.bitA}</td>
                    <td>${step.bitB}</td>
                    <td>${step.carry}</td>
                    <td>${step.sum}</td>
                    <td><strong>${step.result}</strong></td>
                    <td>${step.newCarry}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>🎯 Výsledek sčítání:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} + ${num2.decimal} = ${parseInt(result.result, 2)}</div>
                    <div>Binárně: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displaySubtractionSteps(num1, num2, result) {
            if (result.note) {
                return `<div class="section">
                    <h2>⚠️ Odčítání</h2>
                    <div class="error">${result.note}</div>
                </div>`;
            }
            
            let html = `<div class="section">
                <h2>➖ Odčítání krok za krokem</h2>
                <div class="info-box">
                    <strong>Pravidla binárního odčítání:</strong><br>
                    0 - 0 = 0, &nbsp; 1 - 0 = 1, &nbsp; 1 - 1 = 0, &nbsp; 0 - 1 = 1 (s výpůjčkou)
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;${num1.binary}<br>
                        - ${num2.binary}<br>
                        ─────────<br>
                        &nbsp;&nbsp;${result.result.padStart(num1.binary.length, '0')}
                    </div>
                </div>
                
                <h3>Postupné kroky:</h3>
                <table class="table">
                    <tr><th>Pozice</th><th>Původní A</th><th>A po výpůjčce</th><th>B</th><th>Výpůjčka</th><th>Rozdíl</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.position}</td>
                    <td>${step.originalA}</td>
                    <td>${step.bitA}</td>
                    <td>${step.bitB}</td>
                    <td>${step.borrow}</td>
                    <td><strong>${step.result}</strong></td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>🎯 Výsledek odčítání:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} - ${num2.decimal} = ${parseInt(result.result, 2)}</div>
                    <div>Binárně: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displayMultiplicationSteps(num1, num2, result) {
            let html = `<div class="section">
                <h2>✖️ Násobení krok za krokem</h2>
                <div class="info-box">
                    <strong>Binární násobení:</strong><br>
                    Stejně jako v desítkové soustavě - násobíme každým bitem a posouváme pozice.
                </div>
                
                <div class="binary-display">
                    <div style="text-align: right; font-family: monospace;">
                        &nbsp;&nbsp;&nbsp;&nbsp;${num1.binary}<br>
                        ×&nbsp;&nbsp;&nbsp;&nbsp;${num2.binary}<br>
                        ──────────<br>`;
            
            for (let product of result.partialProducts) {
                html += `&nbsp;&nbsp;${product.product}<br>`;
            }
            
            html += `──────────<br>`;
            html += `&nbsp;&nbsp;${result.result}<br>`;
            html += `</div></div>`;
            
            html += `<h3>Částečné součiny:</h3>
                <table class="table">
                    <tr><th>Bit násobitele</th><th>Posun</th><th>Částečný součin</th></tr>`;
            
            for (let product of result.partialProducts) {
                html += `<tr>
                    <td>${product.multiplier} (pozice ${product.position})</td>
                    <td>${product.shift} pozic vlevo</td>
                    <td class="binary-display" style="font-size: 14px;">${product.product}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>🎯 Výsledek násobení:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} × ${num2.decimal} = ${result.decimalResult}</div>
                    <div>Binárně: ${result.result}</div>
                </div>
            </div>`;
            
            return html;
        }

        function displayDivisionSteps(num1, num2, result) {
            if (result.error) {
                return `<div class="section">
                    <h2>⚠️ Dělení</h2>
                    <div class="error">${result.error}</div>
                </div>`;
            }
            
            let html = `<div class="section">
                <h2>➗ Dělení krok za krokem</h2>
                <div class="info-box">
                    <strong>Binární dělení:</strong><br>
                    Podobné dlouhému dělení - porovnáváme a odčítáme postupně.
                </div>
                
                <h3>Postupné kroky:</h3>
                <table class="table">
                    <tr><th>Krok</th><th>Aktuální dělenec</th><th>Porovnání</th><th>Bit podílu</th><th>Zbytek</th></tr>`;
            
            for (let step of result.steps) {
                html += `<tr>
                    <td>${step.step}</td>
                    <td class="binary-display" style="font-size: 14px;">${step.currentDividend}</td>
                    <td>${step.comparison}</td>
                    <td><strong>${step.quotientBit}</strong></td>
                    <td>${step.newRemainder}</td>
                </tr>`;
            }
            
            html += `</table>
                <div class="final-result">
                    <h3>🎯 Výsledek dělení:</h3>
                    <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} ÷ ${num2.decimal} = ${result.decimalQuotient} se zbytkem ${result.decimalRemainder}</div>
                    <div>Podíl binárně: ${result.quotient}</div>
                    <div>Zbytek binárně: ${result.remainder}</div>
                </div>
            </div>`;
            
            return html;
        }
        function nonRestoringDivision(dividend, divisor) {
                let decimalDividend = parseInt(dividend, 2);
                let decimalDivisor = parseInt(divisor, 2);
                
                if (decimalDivisor === 0) {
                    return { error: 'Dělení nulou!' };
                }
                
                let n = dividend.length;
                let A = 0; // Akumulátor
                let Q = decimalDividend; // Kvocient
                let M = decimalDivisor; // Dělitel
                let quotient = '';
                let steps = [];
                
                for (let i = 0; i < n; i++) {
                    let stepData = {
                        step: i + 1,
                        initialA: A,
                        initialQ: Q.toString(2).padStart(n, '0'),
                        operation: '',
                        newA: 0,
                        newQ: '',
                        quotientBit: '',
                        description: ''
                    };
                    
                    // 1. Posun AQ doleva (kromě prvního kroku)
                    if (i > 0) {
                        let qMSB = Math.floor(Q / Math.pow(2, n-1));
                        A = (A * 2) + qMSB;
                        Q = (Q * 2) % Math.pow(2, n);
                    }
                    
                    // 2. Operace podle znaménka A
                    let newA;
                    if (A >= 0) {
                        newA = A - M;
                        stepData.operation = `${A} - ${M} = ${newA}`;
                        stepData.description = 'Posun + odečtení dělitele';
                    } else {
                        newA = A + M;
                        stepData.operation = `${A} + ${M} = ${newA}`;
                        stepData.description = 'Posun + přičtení dělitele';
                    }
                    
                    A = newA;
                    
                    // 3. Určení bitu kvocientu
                    if (A >= 0) {
                        quotient += '1';
                        stepData.quotientBit = '1';
                        Q = Q | 1;
                        stepData.description += ' → bit 1 (A ≥ 0)';
                    } else {
                        quotient += '0';
                        stepData.quotientBit = '0';
                        Q = Q & ~1;
                        stepData.description += ' → bit 0 (A < 0)';
                    }
                    
                    stepData.newA = A;
                    stepData.newQ = Q.toString(2).padStart(n, '0');
                    
                    steps.push(stepData);
                }
                
                // Korekce zbytku pokud je záporný
                if (A < 0) {
                    A = A + M;
                    steps.push({
                        step: 'Korekce',
                        description: 'Přičtení dělitele k zápornému zbytku',
                        operation: `${A - M} + ${M} = ${A}`,
                        finalCorrection: true
                    });
                }
                
                return {
                    quotient: quotient.replace(/^0+/, '') || '0',
                    remainder: Math.abs(A).toString(2),
                    steps: steps,
                    decimalQuotient: Math.floor(decimalDividend / decimalDivisor),
                    decimalRemainder: decimalDividend % decimalDivisor,
                    algorithm: 'non-restoring'
                };
            }
            
            function displayNonRestoringSteps(num1, num2, result) {
                if (result.error) {
                    return `<div class="section">
                        <h2>⚠️ Dělení bez restaurace</h2>
                        <div class="error">${result.error}</div>
                    </div>`;
                }
                
                let html = `<div class="section">
                    <h2>🔄 Dělení bez restaurace zbytku</h2>
                    <div class="info-box">
                        <strong>Algoritmus bez restaurace:</strong><br>
                        a) Odečti dělitel od akumulátoru<br>
                        b) Na základě MSB urči bit kvocientu (MSB=0 → bit 1, MSB=1 → bit 0)<br>
                        c) Posuň AQ doleva (×2), MSB se zahodí<br>
                        d) Pokud je výsledek záporný, pokračuj (bez restaurace)<br>
                        e) Opakuj dokud není dosažen maximální posun<br>
                        f) Na konci může být nutná korekce zbytku
                    </div>
                    
                    <div class="calculation-step">
                        <strong>Inicializace:</strong><br>
                        A (akumulátor): ${'0'.repeat(num1.binary.length)}<br>
                        Q (kvocient): ${num1.binary}<br>
                        M (dělitel): ${num2.binary}
                    </div>
                    
                    <h3>Postupné kroky:</h3>
                    <table class="table">
                        <tr>
                            <th>Krok</th>
                            <th>Operace</th>
                            <th>Nový A</th>
                            <th>Nový Q</th>
                            <th>Q bit</th>
                            <th>Popis</th>
                        </tr>`;
                
                for (let step of result.steps) {
                    if (step.finalCorrection) {
                        html += `<tr style="background: #fff3cd;">
                            <td><strong>Korekce</strong></td>
                            <td>${step.operation}</td>
                            <td colspan="3">Finální korekce zbytku</td>
                            <td>${step.description}</td>
                        </tr>`;
                    } else {
                        html += `<tr>
                            <td>${step.step}</td>
                            <td>${step.operation}</td>
                            <td class="binary-display" style="font-size: 12px; padding: 4px;">${step.newA}</td>
                            <td class="binary-display" style="font-size: 12px; padding: 4px;">${step.newQ}</td>
                            <td><strong>${step.quotientBit}</strong></td>
                            <td style="font-size: 12px;">${step.description}</td>
                        </tr>`;
                    }
                }
                
                html += `</table>
                    
                    <div class="calculation-step">
                        <strong>Výhody algoritmu bez restaurace:</strong><br>
                        • Rychlejší než klasické dělení (méně operací)<br>
                        • Nemusíme vracet (restaurovat) záporné mezivýsledky<br>
                        • Vhodný pro hardware implementaci<br>
                        • Používá se v moderních procesorech
                    </div>
                    
                    <div class="final-result">
                        <h3>🎯 Výsledek dělení bez restaurace:</h3>
                        <div style="font-size: 24px; margin: 15px 0;">${num1.decimal} ÷ ${num2.decimal} = ${result.decimalQuotient} se zbytkem ${result.decimalRemainder}</div>
                        <div>Podíl binárně: ${result.quotient}</div>
                        <div>Zbytek binárně: ${result.remainder}</div>
                        <div style="margin-top: 10px; font-size: 14px;">
                            <strong>Efektivita:</strong> Algoritmus bez restaurace je rychlejší než klasické dělení
                        </div>
                    </div>
                </div>`;
                
                return html;
            }

        // Initialize on load
        window.onload = function() {
            runQuineMcCluskey();
            calculateIEEE754Addition();
            calculateBinaryArithmetic();
        };
    </script>
</body>
</html>
